diff --git a/clang/test/CodeGen/RISCV/riscv32-ilp32e-abi.c b/clang/test/CodeGen/RISCV/riscv32-ilp32e-abi.c
new file mode 100644
index 000000000000..ae6fc558bb43
--- /dev/null
+++ b/clang/test/CodeGen/RISCV/riscv32-ilp32e-abi.c
@@ -0,0 +1,262 @@
+// RUN: %clang_cc1 -triple riscv32 -emit-llvm -target-abi ilp32e %s -o - \
+// RUN:     | FileCheck -check-prefix=ILP32E %s
+// RUN: not %clang_cc1 -triple riscv32 -target-feature +d -target-feature +f -emit-llvm -target-abi ilp32e %s 2>&1 \
+// RUN:     | FileCheck -check-prefix=ILP32E-WITH-FD %s
+
+// This file contains test cases for only ilp32e.
+
+// ILP32E-WITH-FD: error: invalid feature combination: ILP32E must not be used with the D ISA extension
+
+#include <stddef.h>
+#include <stdint.h>
+
+struct tiny {
+  uint8_t a, b, c, d;
+};
+
+struct small {
+  int32_t a, *b;
+};
+
+struct small_aligned {
+  int64_t a;
+};
+
+struct large {
+  int32_t a, b, c, d;
+};
+
+// Scalars passed on the stack should not have signext/zeroext attributes
+// (they are anyext).
+
+// ILP32E-LABEL: define{{.*}} i32 @f_scalar_stack_1(i32 %a.coerce, [2 x i32] %b.coerce, %struct.large* noundef %c, i8 noundef zeroext %d, i8 noundef signext %e, i8 noundef %f, i8 noundef %g)
+int f_scalar_stack_1(struct tiny a, struct small b, struct large c,
+                     uint8_t d, int8_t e, uint8_t f, int8_t g) {
+  return f + g;
+}
+
+// Ensure that scalars passed on the stack are still determined correctly in
+// the presence of large return values that consume a register due to the need
+// to pass a pointer.
+
+// ILP32E-LABEL: define{{.*}} void @f_scalar_stack_2(%struct.large* noalias sret(%struct.large) align 4 %agg.result, i32 noundef %a, i64 noundef %b, fp128 noundef %c, i8 noundef zeroext %d, i8 noundef %e, i8 noundef %f)
+struct large f_scalar_stack_2(int32_t a, int64_t b, long double c,
+                              uint8_t d, int8_t e, uint8_t f) {
+  return (struct large){a, d, e, f};
+}
+
+// ILP32E-LABEL: define{{.*}} fp128 @f_scalar_stack_4(i32 noundef %a, i64 noundef %b, fp128 noundef %c, i8 noundef zeroext %d, i8 noundef %e, i8 noundef %f)
+long double f_scalar_stack_4(int32_t a, int64_t b, long double c,
+                             uint8_t d, int8_t e, uint8_t f) {
+  return c;
+}
+
+// Aggregates and >=XLen scalars passed on the stack should be lowered just as
+// they would be if passed via registers.
+
+// ILP32E-LABEL: define{{.*}} void @f_scalar_stack_5(double noundef %a, i64 noundef %b, double noundef %c, i32 noundef %d, i64 noundef %e, float noundef %f, double noundef %g, fp128 noundef %h)
+void f_scalar_stack_5(double a, int64_t b, double c, int d,
+                      int64_t e, float f, double g, long double h) {}
+
+// ILP32E-LABEL: define{{.*}} void @f_agg_stack(double noundef %a, i64 noundef %b, double noundef %c, i32 %d.coerce, [2 x i32] %e.coerce, i64 %f.coerce, %struct.large* noundef %g)
+void f_agg_stack(double a, int64_t b, double c, struct tiny d,
+                 struct small e, struct small_aligned f, struct large g) {}
+
+// An "aligned" register pair (where the first register is even-numbered) is
+// used to pass varargs with 2x xlen alignment and 2x xlen size. While using
+// ilp32e, we don't do such alignment.
+
+// ILP32E-LABEL: @f_va_2(
+// ILP32E-NEXT:  entry:
+// ILP32E-NEXT:    [[FMT_ADDR:%.*]] = alloca i8*, align 4
+// ILP32E-NEXT:    [[VA:%.*]] = alloca i8*, align 4
+// ILP32E-NEXT:    [[V:%.*]] = alloca double, align 8
+// ILP32E-NEXT:    store i8* [[FMT:%.*]], i8** [[FMT_ADDR]], align 4
+// ILP32E-NEXT:    [[VA1:%.*]] = bitcast i8** [[VA]] to i8*
+// ILP32E-NEXT:    call void @llvm.va_start(i8* [[VA1]])
+// ILP32E-NEXT:    [[ARGP_CUR:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR]], i32 8
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP0:%.*]] = bitcast i8* [[ARGP_CUR]] to double*
+// ILP32E-NEXT:    [[TMP1:%.*]] = load double, double* [[TMP0]], align 4
+// ILP32E-NEXT:    store double [[TMP1]], double* [[V]], align 8
+// ILP32E-NEXT:    [[VA2:%.*]] = bitcast i8** [[VA]] to i8*
+// ILP32E-NEXT:    call void @llvm.va_end(i8* [[VA2]])
+// ILP32E-NEXT:    [[TMP2:%.*]] = load double, double* [[V]], align 8
+// ILP32E-NEXT:    ret double [[TMP2]]
+//
+double f_va_2(char *fmt, ...) {
+  __builtin_va_list va;
+
+  __builtin_va_start(va, fmt);
+  double v = __builtin_va_arg(va, double);
+  __builtin_va_end(va);
+
+  return v;
+}
+
+// ILP32E-LABEL: @f_va_3(
+// ILP32E-NEXT:  entry:
+// ILP32E-NEXT:    [[FMT_ADDR:%.*]] = alloca i8*, align 4
+// ILP32E-NEXT:    [[VA:%.*]] = alloca i8*, align 4
+// ILP32E-NEXT:    [[V:%.*]] = alloca double, align 8
+// ILP32E-NEXT:    [[W:%.*]] = alloca i32, align 4
+// ILP32E-NEXT:    [[X:%.*]] = alloca double, align 8
+// ILP32E-NEXT:    store i8* [[FMT:%.*]], i8** [[FMT_ADDR]], align 4
+// ILP32E-NEXT:    [[VA1:%.*]] = bitcast i8** [[VA]] to i8*
+// ILP32E-NEXT:    call void @llvm.va_start(i8* [[VA1]])
+// ILP32E-NEXT:    [[ARGP_CUR:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR]], i32 8
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP0:%.*]] = bitcast i8* [[ARGP_CUR]] to double*
+// ILP32E-NEXT:    [[TMP1:%.*]] = load double, double* [[TMP0]], align 4
+// ILP32E-NEXT:    store double [[TMP1]], double* [[V]], align 8
+// ILP32E-NEXT:    [[ARGP_CUR2:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT3:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR2]], i32 4
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT3]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP2:%.*]] = bitcast i8* [[ARGP_CUR2]] to i32*
+// ILP32E-NEXT:    [[TMP3:%.*]] = load i32, i32* [[TMP2]], align 4
+// ILP32E-NEXT:    store i32 [[TMP3]], i32* [[W]], align 4
+// ILP32E-NEXT:    [[ARGP_CUR4:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT5:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR4]], i32 8
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT5]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP4:%.*]] = bitcast i8* [[ARGP_CUR4]] to double*
+// ILP32E-NEXT:    [[TMP5:%.*]] = load double, double* [[TMP4]], align 4
+// ILP32E-NEXT:    store double [[TMP5]], double* [[X]], align 8
+// ILP32E-NEXT:    [[VA6:%.*]] = bitcast i8** [[VA]] to i8*
+// ILP32E-NEXT:    call void @llvm.va_end(i8* [[VA6]])
+// ILP32E-NEXT:    [[TMP6:%.*]] = load double, double* [[V]], align 8
+// ILP32E-NEXT:    [[TMP7:%.*]] = load double, double* [[X]], align 8
+// ILP32E-NEXT:    [[ADD:%.*]] = fadd double [[TMP6]], [[TMP7]]
+// ILP32E-NEXT:    ret double [[ADD]]
+//
+double f_va_3(char *fmt, ...) {
+  __builtin_va_list va;
+
+  __builtin_va_start(va, fmt);
+  double v = __builtin_va_arg(va, double);
+  int w = __builtin_va_arg(va, int);
+  double x = __builtin_va_arg(va, double);
+  __builtin_va_end(va);
+
+  return v + x;
+}
+
+// ILP32E-LABEL: @f_va_4(
+// ILP32E-NEXT:  entry:
+// ILP32E-NEXT:    [[FMT_ADDR:%.*]] = alloca i8*, align 4
+// ILP32E-NEXT:    [[VA:%.*]] = alloca i8*, align 4
+// ILP32E-NEXT:    [[V:%.*]] = alloca i32, align 4
+// ILP32E-NEXT:    [[LD:%.*]] = alloca fp128, align 16
+// ILP32E-NEXT:    [[TS:%.*]] = alloca [[STRUCT_TINY:%.*]], align 1
+// ILP32E-NEXT:    [[SS:%.*]] = alloca [[STRUCT_SMALL:%.*]], align 4
+// ILP32E-NEXT:    [[LS:%.*]] = alloca [[STRUCT_LARGE:%.*]], align 4
+// ILP32E-NEXT:    [[RET:%.*]] = alloca i32, align 4
+// ILP32E-NEXT:    store i8* [[FMT:%.*]], i8** [[FMT_ADDR]], align 4
+// ILP32E-NEXT:    [[VA1:%.*]] = bitcast i8** [[VA]] to i8*
+// ILP32E-NEXT:    call void @llvm.va_start(i8* [[VA1]])
+// ILP32E-NEXT:    [[ARGP_CUR:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR]], i32 4
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP0:%.*]] = bitcast i8* [[ARGP_CUR]] to i32*
+// ILP32E-NEXT:    [[TMP1:%.*]] = load i32, i32* [[TMP0]], align 4
+// ILP32E-NEXT:    store i32 [[TMP1]], i32* [[V]], align 4
+// ILP32E-NEXT:    [[ARGP_CUR2:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT3:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR2]], i32 4
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT3]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP2:%.*]] = bitcast i8* [[ARGP_CUR2]] to fp128**
+// ILP32E-NEXT:    [[TMP3:%.*]] = load fp128*, fp128** [[TMP2]], align 4
+// ILP32E-NEXT:    [[TMP4:%.*]] = load fp128, fp128* [[TMP3]], align 4
+// ILP32E-NEXT:    store fp128 [[TMP4]], fp128* [[LD]], align 16
+// ILP32E-NEXT:    [[ARGP_CUR4:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT5:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR4]], i32 4
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT5]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP5:%.*]] = bitcast i8* [[ARGP_CUR4]] to %struct.tiny*
+// ILP32E-NEXT:    [[TMP6:%.*]] = bitcast %struct.tiny* [[TS]] to i8*
+// ILP32E-NEXT:    [[TMP7:%.*]] = bitcast %struct.tiny* [[TMP5]] to i8*
+// ILP32E-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 1 [[TMP6]], i8* align 4 [[TMP7]], i32 4, i1 false)
+// ILP32E-NEXT:    [[ARGP_CUR6:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT7:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR6]], i32 8
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT7]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP8:%.*]] = bitcast i8* [[ARGP_CUR6]] to %struct.small*
+// ILP32E-NEXT:    [[TMP9:%.*]] = bitcast %struct.small* [[SS]] to i8*
+// ILP32E-NEXT:    [[TMP10:%.*]] = bitcast %struct.small* [[TMP8]] to i8*
+// ILP32E-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 [[TMP9]], i8* align 4 [[TMP10]], i32 8, i1 false)
+// ILP32E-NEXT:    [[ARGP_CUR8:%.*]] = load i8*, i8** [[VA]], align 4
+// ILP32E-NEXT:    [[ARGP_NEXT9:%.*]] = getelementptr inbounds i8, i8* [[ARGP_CUR8]], i32 4
+// ILP32E-NEXT:    store i8* [[ARGP_NEXT9]], i8** [[VA]], align 4
+// ILP32E-NEXT:    [[TMP11:%.*]] = bitcast i8* [[ARGP_CUR8]] to %struct.large**
+// ILP32E-NEXT:    [[TMP12:%.*]] = load %struct.large*, %struct.large** [[TMP11]], align 4
+// ILP32E-NEXT:    [[TMP13:%.*]] = bitcast %struct.large* [[LS]] to i8*
+// ILP32E-NEXT:    [[TMP14:%.*]] = bitcast %struct.large* [[TMP12]] to i8*
+// ILP32E-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i32(i8* align 4 [[TMP13]], i8* align 4 [[TMP14]], i32 16, i1 false)
+// ILP32E-NEXT:    [[VA10:%.*]] = bitcast i8** [[VA]] to i8*
+// ILP32E-NEXT:    call void @llvm.va_end(i8* [[VA10]])
+// ILP32E-NEXT:    [[TMP15:%.*]] = load i32, i32* [[V]], align 4
+// ILP32E-NEXT:    [[CONV:%.*]] = sitofp i32 [[TMP15]] to fp128
+// ILP32E-NEXT:    [[TMP16:%.*]] = load fp128, fp128* [[LD]], align 16
+// ILP32E-NEXT:    [[ADD:%.*]] = fadd fp128 [[CONV]], [[TMP16]]
+// ILP32E-NEXT:    [[CONV11:%.*]] = fptosi fp128 [[ADD]] to i32
+// ILP32E-NEXT:    store i32 [[CONV11]], i32* [[RET]], align 4
+// ILP32E-NEXT:    [[TMP17:%.*]] = load i32, i32* [[RET]], align 4
+// ILP32E-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_TINY]], %struct.tiny* [[TS]], i32 0, i32 0
+// ILP32E-NEXT:    [[TMP18:%.*]] = load i8, i8* [[A]], align 1
+// ILP32E-NEXT:    [[CONV12:%.*]] = zext i8 [[TMP18]] to i32
+// ILP32E-NEXT:    [[ADD13:%.*]] = add nsw i32 [[TMP17]], [[CONV12]]
+// ILP32E-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_TINY]], %struct.tiny* [[TS]], i32 0, i32 1
+// ILP32E-NEXT:    [[TMP19:%.*]] = load i8, i8* [[B]], align 1
+// ILP32E-NEXT:    [[CONV14:%.*]] = zext i8 [[TMP19]] to i32
+// ILP32E-NEXT:    [[ADD15:%.*]] = add nsw i32 [[ADD13]], [[CONV14]]
+// ILP32E-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_TINY]], %struct.tiny* [[TS]], i32 0, i32 2
+// ILP32E-NEXT:    [[TMP20:%.*]] = load i8, i8* [[C]], align 1
+// ILP32E-NEXT:    [[CONV16:%.*]] = zext i8 [[TMP20]] to i32
+// ILP32E-NEXT:    [[ADD17:%.*]] = add nsw i32 [[ADD15]], [[CONV16]]
+// ILP32E-NEXT:    [[D:%.*]] = getelementptr inbounds [[STRUCT_TINY]], %struct.tiny* [[TS]], i32 0, i32 3
+// ILP32E-NEXT:    [[TMP21:%.*]] = load i8, i8* [[D]], align 1
+// ILP32E-NEXT:    [[CONV18:%.*]] = zext i8 [[TMP21]] to i32
+// ILP32E-NEXT:    [[ADD19:%.*]] = add nsw i32 [[ADD17]], [[CONV18]]
+// ILP32E-NEXT:    store i32 [[ADD19]], i32* [[RET]], align 4
+// ILP32E-NEXT:    [[TMP22:%.*]] = load i32, i32* [[RET]], align 4
+// ILP32E-NEXT:    [[A20:%.*]] = getelementptr inbounds [[STRUCT_SMALL]], %struct.small* [[SS]], i32 0, i32 0
+// ILP32E-NEXT:    [[TMP23:%.*]] = load i32, i32* [[A20]], align 4
+// ILP32E-NEXT:    [[ADD21:%.*]] = add nsw i32 [[TMP22]], [[TMP23]]
+// ILP32E-NEXT:    [[B22:%.*]] = getelementptr inbounds [[STRUCT_SMALL]], %struct.small* [[SS]], i32 0, i32 1
+// ILP32E-NEXT:    [[TMP24:%.*]] = load i32*, i32** [[B22]], align 4
+// ILP32E-NEXT:    [[TMP25:%.*]] = ptrtoint i32* [[TMP24]] to i32
+// ILP32E-NEXT:    [[ADD23:%.*]] = add nsw i32 [[ADD21]], [[TMP25]]
+// ILP32E-NEXT:    store i32 [[ADD23]], i32* [[RET]], align 4
+// ILP32E-NEXT:    [[TMP26:%.*]] = load i32, i32* [[RET]], align 4
+// ILP32E-NEXT:    [[A24:%.*]] = getelementptr inbounds [[STRUCT_LARGE]], %struct.large* [[LS]], i32 0, i32 0
+// ILP32E-NEXT:    [[TMP27:%.*]] = load i32, i32* [[A24]], align 4
+// ILP32E-NEXT:    [[ADD25:%.*]] = add nsw i32 [[TMP26]], [[TMP27]]
+// ILP32E-NEXT:    [[B26:%.*]] = getelementptr inbounds [[STRUCT_LARGE]], %struct.large* [[LS]], i32 0, i32 1
+// ILP32E-NEXT:    [[TMP28:%.*]] = load i32, i32* [[B26]], align 4
+// ILP32E-NEXT:    [[ADD27:%.*]] = add nsw i32 [[ADD25]], [[TMP28]]
+// ILP32E-NEXT:    [[C28:%.*]] = getelementptr inbounds [[STRUCT_LARGE]], %struct.large* [[LS]], i32 0, i32 2
+// ILP32E-NEXT:    [[TMP29:%.*]] = load i32, i32* [[C28]], align 4
+// ILP32E-NEXT:    [[ADD29:%.*]] = add nsw i32 [[ADD27]], [[TMP29]]
+// ILP32E-NEXT:    [[D30:%.*]] = getelementptr inbounds [[STRUCT_LARGE]], %struct.large* [[LS]], i32 0, i32 3
+// ILP32E-NEXT:    [[TMP30:%.*]] = load i32, i32* [[D30]], align 4
+// ILP32E-NEXT:    [[ADD31:%.*]] = add nsw i32 [[ADD29]], [[TMP30]]
+// ILP32E-NEXT:    store i32 [[ADD31]], i32* [[RET]], align 4
+// ILP32E-NEXT:    [[TMP31:%.*]] = load i32, i32* [[RET]], align 4
+// ILP32E-NEXT:    ret i32 [[TMP31]]
+//
+int f_va_4(char *fmt, ...) {
+  __builtin_va_list va;
+
+  __builtin_va_start(va, fmt);
+  int v = __builtin_va_arg(va, int);
+  long double ld = __builtin_va_arg(va, long double);
+  struct tiny ts = __builtin_va_arg(va, struct tiny);
+  struct small ss = __builtin_va_arg(va, struct small);
+  struct large ls = __builtin_va_arg(va, struct large);
+  __builtin_va_end(va);
+
+  int ret = (int)((long double)v + ld);
+  ret = ret + ts.a + ts.b + ts.c + ts.d;
+  ret = ret + ss.a + (int)ss.b;
+  ret = ret + ls.a + ls.b + ls.c + ls.d;
+
+  return ret;
+}
diff --git a/lld/ELF/Arch/RISCV.cpp b/lld/ELF/Arch/RISCV.cpp
index a0ea403e241d..c0a684eb5a0e 100644
--- a/lld/ELF/Arch/RISCV.cpp
+++ b/lld/ELF/Arch/RISCV.cpp
@@ -125,9 +125,9 @@ uint32_t RISCV::calcEFlags() const {
       error(toString(f) +
             ": cannot link object files with different floating-point ABI");
 
-    if ((eflags & EF_RISCV_RVE) != (target & EF_RISCV_RVE))
-      error(toString(f) +
-            ": cannot link object files with different EF_RISCV_RVE");
+ //   if ((eflags & EF_RISCV_RVE) != (target & EF_RISCV_RVE))
+ //     error(toString(f) +
+ //           ": cannot link object files with different EF_RISCV_RVE");
   }
 
   return target;
diff --git a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
index 144e761f002d..12770740f249 100644
--- a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
+++ b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
@@ -58,6 +58,11 @@ ABI computeTargetABI(const Triple &TT, FeatureBitset FeatureBits,
     TargetABI = ABI_Unknown;
   }
 
+  if ((TargetABI == RISCVABI::ABI::ABI_ILP32E ||
+       (TargetABI == ABI_Unknown && IsRV32E)) &&
+      FeatureBits[RISCV::FeatureStdExtD])
+    report_fatal_error("ILP32E must not be used with the D ISA extension");
+
   if (TargetABI != ABI_Unknown)
     return TargetABI;
 
diff --git a/llvm/lib/Target/RISCV/RISCVCallingConv.td b/llvm/lib/Target/RISCV/RISCVCallingConv.td
index 025454f8fcca..a1031832a2ee 100644
--- a/llvm/lib/Target/RISCV/RISCVCallingConv.td
+++ b/llvm/lib/Target/RISCV/RISCVCallingConv.td
@@ -13,8 +13,10 @@
 // The RISC-V calling convention is handled with custom code in
 // RISCVISelLowering.cpp (CC_RISCV).
 
+def CSR_ILP32E : CalleeSavedRegs<(add X1, X3, X4, X8, X9)>;
+
 def CSR_ILP32_LP64
-    : CalleeSavedRegs<(add X1, X3, X4, X8, X9, (sequence "X%u", 18, 27))>;
+    : CalleeSavedRegs<(add CSR_ILP32E, (sequence "X%u", 18, 27))>;
 
 def CSR_ILP32F_LP64F
     : CalleeSavedRegs<(add CSR_ILP32_LP64,
diff --git a/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp b/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
index 8f250eeb7248..793ca8b6df5e 100644
--- a/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
+++ b/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
@@ -23,6 +23,19 @@
 
 using namespace llvm;
 
+static Align getABIStackAlignment(RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E)
+    return Align(4);
+
+  return Align(16);
+}
+
+RISCVFrameLowering::RISCVFrameLowering(const RISCVSubtarget &STI)
+    : TargetFrameLowering(StackGrowsDown,
+                          getABIStackAlignment(STI.getTargetABI()),
+                          /*LocalAreaOffset=*/0),
+      STI(STI) {}
+
 // For now we use x18, a.k.a s2, as pointer to shadow call stack.
 // User should explicitly set -ffixed-x18 and not use x18 in their asm.
 static void emitSCSPrologue(MachineFunction &MF, MachineBasicBlock &MBB,
diff --git a/llvm/lib/Target/RISCV/RISCVFrameLowering.h b/llvm/lib/Target/RISCV/RISCVFrameLowering.h
index bc3ace786272..0e03aa1c4685 100644
--- a/llvm/lib/Target/RISCV/RISCVFrameLowering.h
+++ b/llvm/lib/Target/RISCV/RISCVFrameLowering.h
@@ -21,11 +21,7 @@ class RISCVSubtarget;
 
 class RISCVFrameLowering : public TargetFrameLowering {
 public:
-  explicit RISCVFrameLowering(const RISCVSubtarget &STI)
-      : TargetFrameLowering(StackGrowsDown,
-                            /*StackAlignment=*/Align(16),
-                            /*LocalAreaOffset=*/0),
-        STI(STI) {}
+  explicit RISCVFrameLowering(const RISCVSubtarget &STI);
 
   void emitPrologue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
   void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
diff --git a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
index 274b86593e0f..24b2ef1fd79c 100644
--- a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
+++ b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
@@ -49,9 +49,6 @@ RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
                                          const RISCVSubtarget &STI)
     : TargetLowering(TM), Subtarget(STI) {
 
-  if (Subtarget.isRV32E())
-    report_fatal_error("Codegen not yet implemented for RV32E");
-
   RISCVABI::ABI ABI = Subtarget.getTargetABI();
   assert(ABI != RISCVABI::ABI_Unknown && "Improperly initialised target ABI");
 
@@ -73,6 +70,7 @@ RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
   default:
     report_fatal_error("Don't know how to lower this ABI");
   case RISCVABI::ABI_ILP32:
+  case RISCVABI::ABI_ILP32E:
   case RISCVABI::ABI_ILP32F:
   case RISCVABI::ABI_ILP32D:
   case RISCVABI::ABI_LP64:
@@ -8772,10 +8770,15 @@ void RISCVTargetLowering::AdjustInstrPostInstrSelection(MachineInstr &MI,
 // register-size fields in the same situations they would be for fixed
 // arguments.
 
-static const MCPhysReg ArgGPRs[] = {
-  RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13,
-  RISCV::X14, RISCV::X15, RISCV::X16, RISCV::X17
-};
+// The GPRs used for passing arguments in the ILP32* and LP64* ABIs, except
+// the ILP32E ABI.
+static const MCPhysReg ArgIGPRs[] = {RISCV::X10, RISCV::X11, RISCV::X12,
+                                     RISCV::X13, RISCV::X14, RISCV::X15,
+                                     RISCV::X16, RISCV::X17};
+// The GPRs used for passing arguments in the ILP32E ABI.
+static const MCPhysReg ArgEGPRs[] = {RISCV::X10, RISCV::X11, RISCV::X12,
+                                     RISCV::X13, RISCV::X14, RISCV::X15};
+// The FPRs used for passing arguments in the ILP32F and LP64F ABIs.
 static const MCPhysReg ArgFPR16s[] = {
   RISCV::F10_H, RISCV::F11_H, RISCV::F12_H, RISCV::F13_H,
   RISCV::F14_H, RISCV::F15_H, RISCV::F16_H, RISCV::F17_H
@@ -8784,6 +8787,7 @@ static const MCPhysReg ArgFPR32s[] = {
   RISCV::F10_F, RISCV::F11_F, RISCV::F12_F, RISCV::F13_F,
   RISCV::F14_F, RISCV::F15_F, RISCV::F16_F, RISCV::F17_F
 };
+// The FPRs used for passing arguments in the ILP32D and LP64D ABIs.
 static const MCPhysReg ArgFPR64s[] = {
   RISCV::F10_D, RISCV::F11_D, RISCV::F12_D, RISCV::F13_D,
   RISCV::F14_D, RISCV::F15_D, RISCV::F16_D, RISCV::F17_D
@@ -8800,21 +8804,61 @@ static const MCPhysReg ArgVRM4s[] = {RISCV::V8M4, RISCV::V12M4, RISCV::V16M4,
                                      RISCV::V20M4};
 static const MCPhysReg ArgVRM8s[] = {RISCV::V8M8, RISCV::V16M8};
 
+// The GPRs used for passing arguments in the FastCC, X5 and X6 might be used
+// for save-restore libcall, so we don't use them.
+static const MCPhysReg FastCCIGPRs[] = {
+    RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13, RISCV::X14,
+    RISCV::X15, RISCV::X16, RISCV::X17, RISCV::X7,  RISCV::X28,
+    RISCV::X29, RISCV::X30, RISCV::X31};
+
+// The GPRs used for passing arguments in the FastCC when using ILP32E.
+static const MCPhysReg FastCCEGPRs[] = {RISCV::X10, RISCV::X11, RISCV::X12,
+                                        RISCV::X13, RISCV::X14, RISCV::X15,
+                                        RISCV::X7};
+
+static ArrayRef<MCPhysReg> getCallingConvArgGPRs(const RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E)
+    return makeArrayRef(ArgEGPRs);
+
+  return makeArrayRef(ArgIGPRs);
+}
+
+static ArrayRef<MCPhysReg> getFastCCGPRs(const RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E)
+    return makeArrayRef(FastCCEGPRs);
+
+  return makeArrayRef(FastCCIGPRs);
+}
+
+static Register getCallingConvLastArgGPR(const RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E)
+    return RISCV::X15;
+
+  return RISCV::X17;
+}
+
 // Pass a 2*XLEN argument that has been split into two XLEN values through
 // registers or the stack as necessary.
 static bool CC_RISCVAssign2XLen(unsigned XLen, CCState &State, CCValAssign VA1,
                                 ISD::ArgFlagsTy ArgFlags1, unsigned ValNo2,
                                 MVT ValVT2, MVT LocVT2,
-                                ISD::ArgFlagsTy ArgFlags2) {
+                                ISD::ArgFlagsTy ArgFlags2, bool EABI) {
   unsigned XLenInBytes = XLen / 8;
+  const RISCVSubtarget &STI =
+      State.getMachineFunction().getSubtarget<RISCVSubtarget>();
+  ArrayRef<MCPhysReg> ArgGPRs = getCallingConvArgGPRs(STI.getTargetABI());
+
   if (Register Reg = State.AllocateReg(ArgGPRs)) {
     // At least one half can be passed via register.
     State.addLoc(CCValAssign::getReg(VA1.getValNo(), VA1.getValVT(), Reg,
                                      VA1.getLocVT(), CCValAssign::Full));
   } else {
     // Both halves must be passed on the stack, with proper alignment.
+    // TODO: To be compatible with GCC's behaviors, we force them to have 4-byte
+    // alignment. This behavior may be changed when RV32E/ILP32E is ratified.
     Align StackAlign =
-        std::max(Align(XLenInBytes), ArgFlags1.getNonZeroOrigAlign());
+        EABI ? Align(XLenInBytes)
+             : std::max(Align(XLenInBytes), ArgFlags1.getNonZeroOrigAlign());
     State.addLoc(
         CCValAssign::getMem(VA1.getValNo(), VA1.getValVT(),
                             State.AllocateStack(XLenInBytes, StackAlign),
@@ -8886,6 +8930,7 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
   default:
     llvm_unreachable("Unexpected ABI");
   case RISCVABI::ABI_ILP32:
+  case RISCVABI::ABI_ILP32E:
   case RISCVABI::ABI_LP64:
     break;
   case RISCVABI::ABI_ILP32F:
@@ -8917,6 +8962,8 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
     LocInfo = CCValAssign::BCvt;
   }
 
+  ArrayRef<MCPhysReg> ArgGPRs = getCallingConvArgGPRs(ABI);
+
   // If this is a variadic argument, the RISC-V calling convention requires
   // that it is assigned an 'even' or 'aligned' register if it has 8-byte
   // alignment (RV32) or 16-byte alignment (RV64). An aligned register should
@@ -8924,12 +8971,16 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
   // legalisation or not. The argument will not be passed by registers if the
   // original type is larger than 2*XLEN, so the register alignment rule does
   // not apply.
+  // TODO: To be compatible with GCC's behaviors, we don't align registers
+  // currently if we are using ILP32E calling convention. This behavior may be
+  // changed when RV32E/ILP32E is ratified.
   unsigned TwoXLenInBytes = (2 * XLen) / 8;
   if (!IsFixed && ArgFlags.getNonZeroOrigAlign() == TwoXLenInBytes &&
-      DL.getTypeAllocSize(OrigTy) == TwoXLenInBytes) {
+      DL.getTypeAllocSize(OrigTy) == TwoXLenInBytes &&
+      ABI != RISCVABI::ABI_ILP32E) {
     unsigned RegIdx = State.getFirstUnallocated(ArgGPRs);
     // Skip 'odd' register if necessary.
-    if (RegIdx != array_lengthof(ArgGPRs) && RegIdx % 2 == 1)
+    if (RegIdx != ArgGPRs.size() && RegIdx % 2 == 1)
       State.AllocateReg(ArgGPRs);
   }
 
@@ -8994,7 +9045,7 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
     PendingLocs.clear();
     PendingArgFlags.clear();
     return CC_RISCVAssign2XLen(XLen, State, VA, AF, ValNo, ValVT, LocVT,
-                               ArgFlags);
+                               ArgFlags, ABI == RISCVABI::ABI_ILP32E);
   }
 
   // Allocate to a register if possible, or else a stack slot.
@@ -9256,6 +9307,7 @@ static SDValue unpackF64OnRV32DSoftABI(SelectionDAG &DAG, SDValue Chain,
   MachineFunction &MF = DAG.getMachineFunction();
   MachineFrameInfo &MFI = MF.getFrameInfo();
   MachineRegisterInfo &RegInfo = MF.getRegInfo();
+  const RISCVSubtarget &STI = MF.getSubtarget<RISCVSubtarget>();
 
   if (VA.isMemLoc()) {
     // f64 is passed on the stack.
@@ -9272,7 +9324,7 @@ static SDValue unpackF64OnRV32DSoftABI(SelectionDAG &DAG, SDValue Chain,
   RegInfo.addLiveIn(VA.getLocReg(), LoVReg);
   SDValue Lo = DAG.getCopyFromReg(Chain, DL, LoVReg, MVT::i32);
   SDValue Hi;
-  if (VA.getLocReg() == RISCV::X17) {
+  if (VA.getLocReg() == getCallingConvLastArgGPR(STI.getTargetABI())) {
     // Second half of f64 is passed on the stack.
     int FI = MFI.CreateFixedObject(4, 0, /*IsImmutable=*/true);
     SDValue FIN = DAG.getFrameIndex(FI, MVT::i32);
@@ -9296,15 +9348,8 @@ static bool CC_RISCV_FastCC(const DataLayout &DL, RISCVABI::ABI ABI,
                             bool IsFixed, bool IsRet, Type *OrigTy,
                             const RISCVTargetLowering &TLI,
                             Optional<unsigned> FirstMaskArgument) {
-
-  // X5 and X6 might be used for save-restore libcall.
-  static const MCPhysReg GPRList[] = {
-      RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13, RISCV::X14,
-      RISCV::X15, RISCV::X16, RISCV::X17, RISCV::X7,  RISCV::X28,
-      RISCV::X29, RISCV::X30, RISCV::X31};
-
   if (LocVT == MVT::i32 || LocVT == MVT::i64) {
-    if (unsigned Reg = State.AllocateReg(GPRList)) {
+    if (unsigned Reg = State.AllocateReg(getFastCCGPRs(ABI))) {
       State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));
       return false;
     }
@@ -9368,7 +9413,7 @@ static bool CC_RISCV_FastCC(const DataLayout &DL, RISCVABI::ABI ABI,
       State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));
     } else {
       // Try and pass the address via a "fast" GPR.
-      if (unsigned GPRReg = State.AllocateReg(GPRList)) {
+      if (unsigned GPRReg = State.AllocateReg(getFastCCGPRs(ABI))) {
         LocInfo = CCValAssign::Indirect;
         LocVT = TLI.getSubtarget().getXLenVT();
         State.addLoc(CCValAssign::getReg(ValNo, ValVT, GPRReg, LocVT, LocInfo));
@@ -9450,6 +9495,8 @@ SDValue RISCVTargetLowering::LowerFormalArguments(
   case CallingConv::Fast:
     break;
   case CallingConv::GHC:
+    if (Subtarget.isRV32E())
+      report_fatal_error("GHC calling convention is not supported on RV32E!");
     if (!MF.getSubtarget().getFeatureBits()[RISCV::FeatureStdExtF] ||
         !MF.getSubtarget().getFeatureBits()[RISCV::FeatureStdExtD])
       report_fatal_error(
@@ -9473,6 +9520,7 @@ SDValue RISCVTargetLowering::LowerFormalArguments(
   EVT PtrVT = getPointerTy(DAG.getDataLayout());
   MVT XLenVT = Subtarget.getXLenVT();
   unsigned XLenInBytes = Subtarget.getXLen() / 8;
+  RISCVABI::ABI ABI = Subtarget.getTargetABI();
   // Used with vargs to acumulate store chains.
   std::vector<SDValue> OutChains;
 
@@ -9527,7 +9575,7 @@ SDValue RISCVTargetLowering::LowerFormalArguments(
   }
 
   if (IsVarArg) {
-    ArrayRef<MCPhysReg> ArgRegs = makeArrayRef(ArgGPRs);
+    ArrayRef<MCPhysReg> ArgRegs = getCallingConvArgGPRs(ABI);
     unsigned Idx = CCInfo.getFirstUnallocated(ArgRegs);
     const TargetRegisterClass *RC = &RISCV::GPRRegClass;
     MachineFrameInfo &MFI = MF.getFrameInfo();
@@ -9692,9 +9740,11 @@ SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
   SmallVector<CCValAssign, 16> ArgLocs;
   CCState ArgCCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
 
-  if (CallConv == CallingConv::GHC)
+  if (CallConv == CallingConv::GHC) {
+    if (Subtarget.isRV32E())
+      report_fatal_error("GHC calling convention is not supported on RV32E!");
     ArgCCInfo.AnalyzeCallOperands(Outs, CC_RISCV_GHC);
-  else
+  } else
     analyzeOutputArgs(MF, ArgCCInfo, Outs, /*IsRet=*/false, &CLI,
                       CallConv == CallingConv::Fast ? CC_RISCV_FastCC
                                                     : CC_RISCV);
@@ -9759,7 +9809,7 @@ SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
       Register RegLo = VA.getLocReg();
       RegsToPass.push_back(std::make_pair(RegLo, Lo));
 
-      if (RegLo == RISCV::X17) {
+      if (RegLo == getCallingConvLastArgGPR(Subtarget.getTargetABI())) {
         // Second half of f64 is passed on the stack.
         // Work out the address of the stack slot.
         if (!StackPtr.getNode())
@@ -9954,9 +10004,9 @@ SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
     Glue = RetValue.getValue(2);
 
     if (VA.getLocVT() == MVT::i32 && VA.getValVT() == MVT::f64) {
-      assert(VA.getLocReg() == ArgGPRs[0] && "Unexpected reg assignment");
+      assert(VA.getLocReg() == RISCV::X10 && "Unexpected reg assignment");
       SDValue RetValue2 =
-          DAG.getCopyFromReg(Chain, DL, ArgGPRs[1], MVT::i32, Glue);
+          DAG.getCopyFromReg(Chain, DL, RISCV::X11, MVT::i32, Glue);
       Chain = RetValue2.getValue(1);
       Glue = RetValue2.getValue(2);
       RetValue = DAG.getNode(RISCVISD::BuildPairF64, DL, MVT::f64, RetValue,
diff --git a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
index 35363bf37c0d..aab6c60b1a9e 100644
--- a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
@@ -62,6 +62,8 @@ RISCVRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
   switch (Subtarget.getTargetABI()) {
   default:
     llvm_unreachable("Unrecognized ABI");
+  case RISCVABI::ABI_ILP32E:
+    return CSR_ILP32E_SaveList;
   case RISCVABI::ABI_ILP32:
   case RISCVABI::ABI_LP64:
     return CSR_ILP32_LP64_SaveList;
@@ -75,12 +77,13 @@ RISCVRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
 }
 
 BitVector RISCVRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
+  const RISCVSubtarget &STI = MF.getSubtarget<RISCVSubtarget>();
   const RISCVFrameLowering *TFI = getFrameLowering(MF);
   BitVector Reserved(getNumRegs());
 
   // Mark any registers requested to be reserved as such
   for (size_t Reg = 0; Reg < getNumRegs(); Reg++) {
-    if (MF.getSubtarget<RISCVSubtarget>().isRegisterReservedByUser(Reg))
+    if (STI.isRegisterReservedByUser(Reg))
       markSuperRegs(Reserved, Reg);
   }
 
@@ -96,6 +99,11 @@ BitVector RISCVRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
   if (TFI->hasBP(MF))
     markSuperRegs(Reserved, RISCVABI::getBPReg()); // bp
 
+  // There are only 16 GPRs for RV32E.
+  if (STI.isRV32E())
+    for (size_t Reg = RISCV::X16; Reg <= RISCV::X31; Reg++)
+      markSuperRegs(Reserved, Reg);
+
   // V registers for code generation. We handle them manually.
   markSuperRegs(Reserved, RISCV::VL);
   markSuperRegs(Reserved, RISCV::VTYPE);
@@ -301,6 +309,8 @@ RISCVRegisterInfo::getCallPreservedMask(const MachineFunction & MF,
   switch (Subtarget.getTargetABI()) {
   default:
     llvm_unreachable("Unrecognized ABI");
+  case RISCVABI::ABI_ILP32E:
+    return CSR_ILP32E_RegMask;
   case RISCVABI::ABI_ILP32:
   case RISCVABI::ABI_LP64:
     return CSR_ILP32_LP64_RegMask;
diff --git a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
index 0248ea0039bc..8557182d60ae 100644
--- a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
+++ b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
@@ -47,10 +47,16 @@ extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeRISCVTarget() {
   initializeRISCVInsertVSETVLIPass(*PR);
 }
 
-static StringRef computeDataLayout(const Triple &TT) {
+static StringRef computeDataLayout(const Triple &TT,
+                                   const TargetOptions &Options) {
   if (TT.isArch64Bit())
     return "e-m:e-p:64:64-i64:64-i128:128-n64-S128";
   assert(TT.isArch32Bit() && "only RV32 and RV64 are currently supported");
+
+  StringRef ABIName = Options.MCOptions.getABIName();
+  if (ABIName == "ilp32e")
+    return "e-m:e-p:32:32-i64:64-n32-S32";
+
   return "e-m:e-p:32:32-i64:64-n32-S128";
 }
 
@@ -67,7 +73,7 @@ RISCVTargetMachine::RISCVTargetMachine(const Target &T, const Triple &TT,
                                        Optional<Reloc::Model> RM,
                                        Optional<CodeModel::Model> CM,
                                        CodeGenOpt::Level OL, bool JIT)
-    : LLVMTargetMachine(T, computeDataLayout(TT), TT, CPU, FS, Options,
+    : LLVMTargetMachine(T, computeDataLayout(TT, Options), TT, CPU, FS, Options,
                         getEffectiveRelocModel(TT, RM),
                         getEffectiveCodeModel(CM, CodeModel::Small), OL),
       TLOF(std::make_unique<RISCVELFTargetObjectFile>()) {
diff --git a/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll b/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll
index db43fdda057e..4e104ed2e87a 100644
--- a/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll
+++ b/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll
@@ -1,6 +1,8 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=ILP32
+; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=ILP32E
 ; RUN: llc -mtriple=riscv64 -mattr=+f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=LP64
 ; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32f -verify-machineinstrs < %s \
@@ -14,8 +16,8 @@
 
 @var = global [32 x float] zeroinitializer
 
-; All floating point registers are temporaries for the ilp32 and lp64 ABIs.
-; fs0-fs11 are callee-saved for the ilp32f, ilp32d, lp64f, and lp64d ABIs.
+; All floating point registers are temporaries for the ilp32, ilp32e, and lp64
+; ABIs. fs0-fs11 are callee-saved for the ilp32f, ilp32d, lp64f, and lp64d ABIs.
 
 ; This function tests that RISCVRegisterInfo::getCalleeSavedRegs returns
 ; something appropriate.
@@ -91,6 +93,76 @@ define void @callee() nounwind {
 ; ILP32-NEXT:    fsw ft0, %lo(var)(a0)
 ; ILP32-NEXT:    ret
 ;
+; ILP32E-LABEL: callee:
+; ILP32E:       # %bb.0:
+; ILP32E-NEXT:    lui a0, %hi(var)
+; ILP32E-NEXT:    flw ft0, %lo(var)(a0)
+; ILP32E-NEXT:    flw ft1, %lo(var+4)(a0)
+; ILP32E-NEXT:    flw ft2, %lo(var+8)(a0)
+; ILP32E-NEXT:    flw ft3, %lo(var+12)(a0)
+; ILP32E-NEXT:    addi a1, a0, %lo(var)
+; ILP32E-NEXT:    flw ft4, 16(a1)
+; ILP32E-NEXT:    flw ft5, 20(a1)
+; ILP32E-NEXT:    flw ft6, 24(a1)
+; ILP32E-NEXT:    flw ft7, 28(a1)
+; ILP32E-NEXT:    flw fa0, 32(a1)
+; ILP32E-NEXT:    flw fa1, 36(a1)
+; ILP32E-NEXT:    flw fa2, 40(a1)
+; ILP32E-NEXT:    flw fa3, 44(a1)
+; ILP32E-NEXT:    flw fa4, 48(a1)
+; ILP32E-NEXT:    flw fa5, 52(a1)
+; ILP32E-NEXT:    flw fa6, 56(a1)
+; ILP32E-NEXT:    flw fa7, 60(a1)
+; ILP32E-NEXT:    flw ft8, 64(a1)
+; ILP32E-NEXT:    flw ft9, 68(a1)
+; ILP32E-NEXT:    flw ft10, 72(a1)
+; ILP32E-NEXT:    flw ft11, 76(a1)
+; ILP32E-NEXT:    flw fs0, 80(a1)
+; ILP32E-NEXT:    flw fs1, 84(a1)
+; ILP32E-NEXT:    flw fs2, 88(a1)
+; ILP32E-NEXT:    flw fs3, 92(a1)
+; ILP32E-NEXT:    flw fs4, 96(a1)
+; ILP32E-NEXT:    flw fs5, 100(a1)
+; ILP32E-NEXT:    flw fs6, 104(a1)
+; ILP32E-NEXT:    flw fs7, 108(a1)
+; ILP32E-NEXT:    flw fs8, 124(a1)
+; ILP32E-NEXT:    flw fs9, 120(a1)
+; ILP32E-NEXT:    flw fs10, 116(a1)
+; ILP32E-NEXT:    flw fs11, 112(a1)
+; ILP32E-NEXT:    fsw fs8, 124(a1)
+; ILP32E-NEXT:    fsw fs9, 120(a1)
+; ILP32E-NEXT:    fsw fs10, 116(a1)
+; ILP32E-NEXT:    fsw fs11, 112(a1)
+; ILP32E-NEXT:    fsw fs7, 108(a1)
+; ILP32E-NEXT:    fsw fs6, 104(a1)
+; ILP32E-NEXT:    fsw fs5, 100(a1)
+; ILP32E-NEXT:    fsw fs4, 96(a1)
+; ILP32E-NEXT:    fsw fs3, 92(a1)
+; ILP32E-NEXT:    fsw fs2, 88(a1)
+; ILP32E-NEXT:    fsw fs1, 84(a1)
+; ILP32E-NEXT:    fsw fs0, 80(a1)
+; ILP32E-NEXT:    fsw ft11, 76(a1)
+; ILP32E-NEXT:    fsw ft10, 72(a1)
+; ILP32E-NEXT:    fsw ft9, 68(a1)
+; ILP32E-NEXT:    fsw ft8, 64(a1)
+; ILP32E-NEXT:    fsw fa7, 60(a1)
+; ILP32E-NEXT:    fsw fa6, 56(a1)
+; ILP32E-NEXT:    fsw fa5, 52(a1)
+; ILP32E-NEXT:    fsw fa4, 48(a1)
+; ILP32E-NEXT:    fsw fa3, 44(a1)
+; ILP32E-NEXT:    fsw fa2, 40(a1)
+; ILP32E-NEXT:    fsw fa1, 36(a1)
+; ILP32E-NEXT:    fsw fa0, 32(a1)
+; ILP32E-NEXT:    fsw ft7, 28(a1)
+; ILP32E-NEXT:    fsw ft6, 24(a1)
+; ILP32E-NEXT:    fsw ft5, 20(a1)
+; ILP32E-NEXT:    fsw ft4, 16(a1)
+; ILP32E-NEXT:    fsw ft3, %lo(var+12)(a0)
+; ILP32E-NEXT:    fsw ft2, %lo(var+8)(a0)
+; ILP32E-NEXT:    fsw ft1, %lo(var+4)(a0)
+; ILP32E-NEXT:    fsw ft0, %lo(var)(a0)
+; ILP32E-NEXT:    ret
+;
 ; LP64-LABEL: callee:
 ; LP64:       # %bb.0:
 ; LP64-NEXT:    lui a0, %hi(var)
@@ -700,6 +772,149 @@ define void @caller() nounwind {
 ; ILP32-NEXT:    addi sp, sp, 144
 ; ILP32-NEXT:    ret
 ;
+; ILP32E-LABEL: caller:
+; ILP32E:       # %bb.0:
+; ILP32E-NEXT:    addi sp, sp, -140
+; ILP32E-NEXT:    sw ra, 136(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    sw s0, 132(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    sw s1, 128(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    lui s0, %hi(var)
+; ILP32E-NEXT:    flw ft0, %lo(var)(s0)
+; ILP32E-NEXT:    fsw ft0, 124(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, %lo(var+4)(s0)
+; ILP32E-NEXT:    fsw ft0, 120(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, %lo(var+8)(s0)
+; ILP32E-NEXT:    fsw ft0, 116(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, %lo(var+12)(s0)
+; ILP32E-NEXT:    fsw ft0, 112(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    addi s1, s0, %lo(var)
+; ILP32E-NEXT:    flw ft0, 16(s1)
+; ILP32E-NEXT:    fsw ft0, 108(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 20(s1)
+; ILP32E-NEXT:    fsw ft0, 104(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 24(s1)
+; ILP32E-NEXT:    fsw ft0, 100(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 28(s1)
+; ILP32E-NEXT:    fsw ft0, 96(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 32(s1)
+; ILP32E-NEXT:    fsw ft0, 92(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 36(s1)
+; ILP32E-NEXT:    fsw ft0, 88(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 40(s1)
+; ILP32E-NEXT:    fsw ft0, 84(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 44(s1)
+; ILP32E-NEXT:    fsw ft0, 80(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 48(s1)
+; ILP32E-NEXT:    fsw ft0, 76(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 52(s1)
+; ILP32E-NEXT:    fsw ft0, 72(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 56(s1)
+; ILP32E-NEXT:    fsw ft0, 68(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 60(s1)
+; ILP32E-NEXT:    fsw ft0, 64(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 64(s1)
+; ILP32E-NEXT:    fsw ft0, 60(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 68(s1)
+; ILP32E-NEXT:    fsw ft0, 56(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 72(s1)
+; ILP32E-NEXT:    fsw ft0, 52(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 76(s1)
+; ILP32E-NEXT:    fsw ft0, 48(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 80(s1)
+; ILP32E-NEXT:    fsw ft0, 44(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 84(s1)
+; ILP32E-NEXT:    fsw ft0, 40(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 88(s1)
+; ILP32E-NEXT:    fsw ft0, 36(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 92(s1)
+; ILP32E-NEXT:    fsw ft0, 32(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 96(s1)
+; ILP32E-NEXT:    fsw ft0, 28(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 100(s1)
+; ILP32E-NEXT:    fsw ft0, 24(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 104(s1)
+; ILP32E-NEXT:    fsw ft0, 20(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 108(s1)
+; ILP32E-NEXT:    fsw ft0, 16(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 112(s1)
+; ILP32E-NEXT:    fsw ft0, 12(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 116(s1)
+; ILP32E-NEXT:    fsw ft0, 8(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 120(s1)
+; ILP32E-NEXT:    fsw ft0, 4(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 124(s1)
+; ILP32E-NEXT:    fsw ft0, 0(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    call callee@plt
+; ILP32E-NEXT:    flw ft0, 0(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 124(s1)
+; ILP32E-NEXT:    flw ft0, 4(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 120(s1)
+; ILP32E-NEXT:    flw ft0, 8(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 116(s1)
+; ILP32E-NEXT:    flw ft0, 12(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 112(s1)
+; ILP32E-NEXT:    flw ft0, 16(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 108(s1)
+; ILP32E-NEXT:    flw ft0, 20(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 104(s1)
+; ILP32E-NEXT:    flw ft0, 24(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 100(s1)
+; ILP32E-NEXT:    flw ft0, 28(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 96(s1)
+; ILP32E-NEXT:    flw ft0, 32(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 92(s1)
+; ILP32E-NEXT:    flw ft0, 36(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 88(s1)
+; ILP32E-NEXT:    flw ft0, 40(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 84(s1)
+; ILP32E-NEXT:    flw ft0, 44(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 80(s1)
+; ILP32E-NEXT:    flw ft0, 48(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 76(s1)
+; ILP32E-NEXT:    flw ft0, 52(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 72(s1)
+; ILP32E-NEXT:    flw ft0, 56(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 68(s1)
+; ILP32E-NEXT:    flw ft0, 60(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 64(s1)
+; ILP32E-NEXT:    flw ft0, 64(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 60(s1)
+; ILP32E-NEXT:    flw ft0, 68(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 56(s1)
+; ILP32E-NEXT:    flw ft0, 72(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 52(s1)
+; ILP32E-NEXT:    flw ft0, 76(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 48(s1)
+; ILP32E-NEXT:    flw ft0, 80(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 44(s1)
+; ILP32E-NEXT:    flw ft0, 84(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 40(s1)
+; ILP32E-NEXT:    flw ft0, 88(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 36(s1)
+; ILP32E-NEXT:    flw ft0, 92(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 32(s1)
+; ILP32E-NEXT:    flw ft0, 96(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 28(s1)
+; ILP32E-NEXT:    flw ft0, 100(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 24(s1)
+; ILP32E-NEXT:    flw ft0, 104(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 20(s1)
+; ILP32E-NEXT:    flw ft0, 108(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 16(s1)
+; ILP32E-NEXT:    flw ft0, 112(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var+12)(s0)
+; ILP32E-NEXT:    flw ft0, 116(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var+8)(s0)
+; ILP32E-NEXT:    flw ft0, 120(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var+4)(s0)
+; ILP32E-NEXT:    flw ft0, 124(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var)(s0)
+; ILP32E-NEXT:    lw ra, 136(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    lw s0, 132(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    lw s1, 128(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    addi sp, sp, 140
+; ILP32E-NEXT:    ret
+;
 ; LP64-LABEL: caller:
 ; LP64:       # %bb.0:
 ; LP64-NEXT:    addi sp, sp, -160
diff --git a/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll b/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll
index 5e0c01ee2678..bd71067e67a5 100644
--- a/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll
+++ b/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll
@@ -1,6 +1,8 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32I-ILP32E
 ; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
 ; RUN: llc -mtriple=riscv32 -mattr=+d -target-abi ilp32f -verify-machineinstrs < %s \
@@ -136,6 +138,96 @@ define void @callee() nounwind {
 ; RV32I-NEXT:    addi sp, sp, 80
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: callee:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -36
+; RV32I-ILP32E-NEXT:    sw ra, 32(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 28(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s1, 24(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lui a7, %hi(var)
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 20(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var+4)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 16(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var+8)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var+12)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 8(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    addi a5, a7, %lo(var)
+; RV32I-ILP32E-NEXT:    lw a0, 16(a5)
+; RV32I-ILP32E-NEXT:    sw a0, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 20(a5)
+; RV32I-ILP32E-NEXT:    sw a0, 0(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw t0, 24(a5)
+; RV32I-ILP32E-NEXT:    lw t1, 28(a5)
+; RV32I-ILP32E-NEXT:    lw t2, 32(a5)
+; RV32I-ILP32E-NEXT:    lw t3, 36(a5)
+; RV32I-ILP32E-NEXT:    lw t4, 40(a5)
+; RV32I-ILP32E-NEXT:    lw t5, 44(a5)
+; RV32I-ILP32E-NEXT:    lw t6, 48(a5)
+; RV32I-ILP32E-NEXT:    lw s2, 52(a5)
+; RV32I-ILP32E-NEXT:    lw s3, 56(a5)
+; RV32I-ILP32E-NEXT:    lw s4, 60(a5)
+; RV32I-ILP32E-NEXT:    lw s5, 64(a5)
+; RV32I-ILP32E-NEXT:    lw s6, 68(a5)
+; RV32I-ILP32E-NEXT:    lw s7, 72(a5)
+; RV32I-ILP32E-NEXT:    lw s8, 76(a5)
+; RV32I-ILP32E-NEXT:    lw s9, 80(a5)
+; RV32I-ILP32E-NEXT:    lw s10, 84(a5)
+; RV32I-ILP32E-NEXT:    lw s11, 88(a5)
+; RV32I-ILP32E-NEXT:    lw s0, 92(a5)
+; RV32I-ILP32E-NEXT:    lw s1, 96(a5)
+; RV32I-ILP32E-NEXT:    lw ra, 100(a5)
+; RV32I-ILP32E-NEXT:    lw a6, 104(a5)
+; RV32I-ILP32E-NEXT:    lw a4, 108(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 124(a5)
+; RV32I-ILP32E-NEXT:    lw a1, 120(a5)
+; RV32I-ILP32E-NEXT:    lw a2, 116(a5)
+; RV32I-ILP32E-NEXT:    lw a3, 112(a5)
+; RV32I-ILP32E-NEXT:    sw a0, 124(a5)
+; RV32I-ILP32E-NEXT:    sw a1, 120(a5)
+; RV32I-ILP32E-NEXT:    sw a2, 116(a5)
+; RV32I-ILP32E-NEXT:    sw a3, 112(a5)
+; RV32I-ILP32E-NEXT:    sw a4, 108(a5)
+; RV32I-ILP32E-NEXT:    sw a6, 104(a5)
+; RV32I-ILP32E-NEXT:    sw ra, 100(a5)
+; RV32I-ILP32E-NEXT:    sw s1, 96(a5)
+; RV32I-ILP32E-NEXT:    sw s0, 92(a5)
+; RV32I-ILP32E-NEXT:    sw s11, 88(a5)
+; RV32I-ILP32E-NEXT:    sw s10, 84(a5)
+; RV32I-ILP32E-NEXT:    sw s9, 80(a5)
+; RV32I-ILP32E-NEXT:    sw s8, 76(a5)
+; RV32I-ILP32E-NEXT:    sw s7, 72(a5)
+; RV32I-ILP32E-NEXT:    sw s6, 68(a5)
+; RV32I-ILP32E-NEXT:    sw s5, 64(a5)
+; RV32I-ILP32E-NEXT:    sw s4, 60(a5)
+; RV32I-ILP32E-NEXT:    sw s3, 56(a5)
+; RV32I-ILP32E-NEXT:    sw s2, 52(a5)
+; RV32I-ILP32E-NEXT:    sw t6, 48(a5)
+; RV32I-ILP32E-NEXT:    sw t5, 44(a5)
+; RV32I-ILP32E-NEXT:    sw t4, 40(a5)
+; RV32I-ILP32E-NEXT:    sw t3, 36(a5)
+; RV32I-ILP32E-NEXT:    sw t2, 32(a5)
+; RV32I-ILP32E-NEXT:    sw t1, 28(a5)
+; RV32I-ILP32E-NEXT:    sw t0, 24(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 0(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 20(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 16(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 8(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+12)(a7)
+; RV32I-ILP32E-NEXT:    lw a0, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+8)(a7)
+; RV32I-ILP32E-NEXT:    lw a0, 16(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+4)(a7)
+; RV32I-ILP32E-NEXT:    lw a0, 20(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var)(a7)
+; RV32I-ILP32E-NEXT:    lw ra, 32(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 28(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s1, 24(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 36
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV32I-WITH-FP-LABEL: callee:
 ; RV32I-WITH-FP:       # %bb.0:
 ; RV32I-WITH-FP-NEXT:    addi sp, sp, -80
@@ -623,6 +715,148 @@ define void @caller() nounwind {
 ; RV32I-NEXT:    addi sp, sp, 144
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -136
+; RV32I-ILP32E-NEXT:    sw ra, 132(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 128(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s1, 124(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lui a0, %hi(var)
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 120(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var+4)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 116(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var+8)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 112(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var+12)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 108(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    addi s1, a0, %lo(var)
+; RV32I-ILP32E-NEXT:    lw a0, 16(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 104(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 20(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 100(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 24(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 96(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 28(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 92(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 32(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 88(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 36(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 84(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 40(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 80(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 44(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 76(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 48(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 72(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 52(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 68(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 56(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 64(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 60(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 60(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 64(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 56(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 68(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 52(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 72(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 48(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 76(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 44(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 80(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 40(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 84(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 36(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 88(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 32(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 92(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 28(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 96(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 24(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 100(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 20(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 104(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 16(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 108(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 112(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 8(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 116(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 120(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 0(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw s0, 124(s1)
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    sw s0, 124(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 0(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 120(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 116(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 8(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 112(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 108(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 16(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 104(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 20(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 100(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 24(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 96(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 28(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 92(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 32(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 88(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 36(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 84(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 40(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 80(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 44(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 76(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 48(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 72(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 52(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 68(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 56(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 64(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 60(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 60(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 64(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 56(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 68(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 52(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 72(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 48(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 76(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 44(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 80(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 40(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 84(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 36(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 88(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 32(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 92(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 28(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 96(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 24(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 100(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 20(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 104(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 16(s1)
+; RV32I-ILP32E-NEXT:    lui a1, %hi(var)
+; RV32I-ILP32E-NEXT:    lw a0, 108(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+12)(a1)
+; RV32I-ILP32E-NEXT:    lw a0, 112(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+8)(a1)
+; RV32I-ILP32E-NEXT:    lw a0, 116(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+4)(a1)
+; RV32I-ILP32E-NEXT:    lw a0, 120(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var)(a1)
+; RV32I-ILP32E-NEXT:    lw ra, 132(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 128(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s1, 124(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 136
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV32I-WITH-FP-LABEL: caller:
 ; RV32I-WITH-FP:       # %bb.0:
 ; RV32I-WITH-FP-NEXT:    addi sp, sp, -144
diff --git a/llvm/test/CodeGen/RISCV/calling-conv-ilp32e.ll b/llvm/test/CodeGen/RISCV/calling-conv-ilp32e.ll
new file mode 100644
index 000000000000..8ee339772ae7
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/calling-conv-ilp32e.ll
@@ -0,0 +1,1493 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-FPELIM %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -frame-pointer=all \
+; RUN:   -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-WITHFP %s
+
+; As well as calling convention details, we check that ra and fp are
+; consistently stored to fp-4 and fp-8.
+
+; Any tests that would have identical output for some combination of the ilp32*
+; ABIs belong in calling-conv-*-common.ll. This file contains tests that will
+; have different output across those ABIs. i.e. where some arguments would be
+; passed according to the floating point ABI, or where the stack is aligned to
+; a different boundary.
+
+define i32 @callee_float_in_regs(i32 %a, float %b) {
+; ILP32E-FPELIM-LABEL: callee_float_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-FPELIM-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    mv s0, a0
+; ILP32E-FPELIM-NEXT:    mv a0, a1
+; ILP32E-FPELIM-NEXT:    call __fixsfsi@plt
+; ILP32E-FPELIM-NEXT:    add a0, s0, a0
+; ILP32E-FPELIM-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 8
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_float_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    mv s1, a0
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    call __fixsfsi@plt
+; ILP32E-WITHFP-NEXT:    add a0, s1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 12
+; ILP32E-WITHFP-NEXT:    ret
+  %b_fptosi = fptosi float %b to i32
+  %1 = add i32 %a, %b_fptosi
+  ret i32 %1
+}
+
+define i32 @caller_float_in_regs() {
+; ILP32E-FPELIM-LABEL: caller_float_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    lui a1, 262144
+; ILP32E-FPELIM-NEXT:    call callee_float_in_regs@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_float_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    lui a1, 262144
+; ILP32E-WITHFP-NEXT:    call callee_float_in_regs@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_float_in_regs(i32 1, float 2.0)
+  ret i32 %1
+}
+
+define i32 @callee_float_on_stack(i64 %a, i64 %b, i64 %c, i64 %d, float %e) {
+; ILP32E-FPELIM-LABEL: callee_float_on_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 0(sp)
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_float_on_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a0, 8(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 0(s0)
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = trunc i64 %d to i32
+  %2 = bitcast float %e to i32
+  %3 = add i32 %1, %2
+  ret i32 %3
+}
+
+define i32 @caller_float_on_stack() {
+; ILP32E-FPELIM-LABEL: caller_float_on_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-FPELIM-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    lui a0, 264704
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a1, 4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a2, 2
+; ILP32E-FPELIM-NEXT:    li a4, 3
+; ILP32E-FPELIM-NEXT:    sw a1, 0(sp)
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    li a3, 0
+; ILP32E-FPELIM-NEXT:    li a5, 0
+; ILP32E-FPELIM-NEXT:    call callee_float_on_stack@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 16
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_float_on_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -20
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 20
+; ILP32E-WITHFP-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 20
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a0, 264704
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a1, 4
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a2, 2
+; ILP32E-WITHFP-NEXT:    li a4, 3
+; ILP32E-WITHFP-NEXT:    sw a1, 0(sp)
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    li a3, 0
+; ILP32E-WITHFP-NEXT:    li a5, 0
+; ILP32E-WITHFP-NEXT:    call callee_float_on_stack@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 20
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_float_on_stack(i64 1, i64 2, i64 3, i64 4, float 5.0)
+  ret i32 %1
+}
+
+define float @callee_tiny_scalar_ret() {
+; ILP32E-FPELIM-LABEL: callee_tiny_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lui a0, 260096
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_tiny_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a0, 260096
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  ret float 1.0
+}
+
+define i32 @caller_tiny_scalar_ret() {
+; ILP32E-FPELIM-LABEL: caller_tiny_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    call callee_tiny_scalar_ret@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_tiny_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    call callee_tiny_scalar_ret@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call float @callee_tiny_scalar_ret()
+  %2 = bitcast float %1 to i32
+  ret i32 %2
+}
+
+; Check that on RV32 ilp32e, double is passed in a pair of registers. Unlike
+; the convention for varargs, this need not be an aligned pair.
+
+define i32 @callee_double_in_regs(i32 %a, double %b) {
+; ILP32E-FPELIM-LABEL: callee_double_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-FPELIM-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    mv s0, a0
+; ILP32E-FPELIM-NEXT:    mv a0, a1
+; ILP32E-FPELIM-NEXT:    mv a1, a2
+; ILP32E-FPELIM-NEXT:    call __fixdfsi@plt
+; ILP32E-FPELIM-NEXT:    add a0, s0, a0
+; ILP32E-FPELIM-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 8
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_double_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    mv s1, a0
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    mv a1, a2
+; ILP32E-WITHFP-NEXT:    call __fixdfsi@plt
+; ILP32E-WITHFP-NEXT:    add a0, s1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 12
+; ILP32E-WITHFP-NEXT:    ret
+  %b_fptosi = fptosi double %b to i32
+  %1 = add i32 %a, %b_fptosi
+  ret i32 %1
+}
+
+define i32 @caller_double_in_regs() {
+; ILP32E-FPELIM-LABEL: caller_double_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    lui a2, 262144
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    call callee_double_in_regs@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_double_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    lui a2, 262144
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call callee_double_in_regs@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_double_in_regs(i32 1, double 2.0)
+  ret i32 %1
+}
+
+; Check 2x*xlen values are aligned appropriately when passed on the stack
+; Must keep define on a single line due to an update_llc_test_checks.py limitation
+define i32 @callee_aligned_stack(i32 %a, i32 %b, fp128 %c, i32 %d, i32 %e, i64 %f, i32 %g, i32 %h, double %i, i32 %j, [2 x i32] %k) {
+; The double should be 8-byte aligned on the stack, but the two-element array
+; should only be 4-byte aligned
+; ILP32E-FPELIM-LABEL: callee_aligned_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a0, 0(a2)
+; ILP32E-FPELIM-NEXT:    lw a1, 24(sp)
+; ILP32E-FPELIM-NEXT:    lw a2, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a3, 8(sp)
+; ILP32E-FPELIM-NEXT:    lw a4, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a5, 20(sp)
+; ILP32E-FPELIM-NEXT:    add a0, a0, a2
+; ILP32E-FPELIM-NEXT:    add a0, a0, a3
+; ILP32E-FPELIM-NEXT:    add a0, a0, a4
+; ILP32E-FPELIM-NEXT:    add a0, a0, a5
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_aligned_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a2)
+; ILP32E-WITHFP-NEXT:    lw a1, 24(s0)
+; ILP32E-WITHFP-NEXT:    lw a2, 4(s0)
+; ILP32E-WITHFP-NEXT:    lw a3, 8(s0)
+; ILP32E-WITHFP-NEXT:    lw a4, 12(s0)
+; ILP32E-WITHFP-NEXT:    lw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    add a0, a0, a2
+; ILP32E-WITHFP-NEXT:    add a0, a0, a3
+; ILP32E-WITHFP-NEXT:    add a0, a0, a4
+; ILP32E-WITHFP-NEXT:    add a0, a0, a5
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = bitcast fp128 %c to i128
+  %2 = trunc i128 %1 to i32
+  %3 = add i32 %2, %g
+  %4 = add i32 %3, %h
+  %5 = bitcast double %i to i64
+  %6 = trunc i64 %5 to i32
+  %7 = add i32 %4, %6
+  %8 = add i32 %7, %j
+  %9 = extractvalue [2 x i32] %k, 0
+  %10 = add i32 %8, %9
+  ret i32 %10
+}
+
+define void @caller_aligned_stack() {
+; The double should be 8-byte aligned on the stack, but the two-element array
+; should only be 4-byte aligned
+; ILP32E-FPELIM-LABEL: caller_aligned_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-FPELIM-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    li a0, 18
+; ILP32E-FPELIM-NEXT:    sw a0, 28(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 17
+; ILP32E-FPELIM-NEXT:    sw a0, 24(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 16
+; ILP32E-FPELIM-NEXT:    sw a0, 20(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 262236
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 655
+; ILP32E-FPELIM-NEXT:    sw a0, 16(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 377487
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 1475
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 15
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 14
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 4
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 262153
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 491
+; ILP32E-FPELIM-NEXT:    sw a0, 44(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 545260
+; ILP32E-FPELIM-NEXT:    addi a0, a0, -1967
+; ILP32E-FPELIM-NEXT:    sw a0, 40(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 964690
+; ILP32E-FPELIM-NEXT:    addi a0, a0, -328
+; ILP32E-FPELIM-NEXT:    sw a0, 36(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 335544
+; ILP32E-FPELIM-NEXT:    addi a6, a0, 1311
+; ILP32E-FPELIM-NEXT:    lui a0, 688509
+; ILP32E-FPELIM-NEXT:    addi a5, a0, -2048
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 11
+; ILP32E-FPELIM-NEXT:    addi a2, sp, 32
+; ILP32E-FPELIM-NEXT:    li a3, 12
+; ILP32E-FPELIM-NEXT:    li a4, 13
+; ILP32E-FPELIM-NEXT:    sw a6, 32(sp)
+; ILP32E-FPELIM-NEXT:    call callee_aligned_stack@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -64
+; ILP32E-FPELIM-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 64
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_aligned_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-WITHFP-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    li a0, 18
+; ILP32E-WITHFP-NEXT:    sw a0, 28(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 17
+; ILP32E-WITHFP-NEXT:    sw a0, 24(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 16
+; ILP32E-WITHFP-NEXT:    sw a0, 20(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262236
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 655
+; ILP32E-WITHFP-NEXT:    sw a0, 16(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 377487
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 1475
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 15
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 14
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 4
+; ILP32E-WITHFP-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262153
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 491
+; ILP32E-WITHFP-NEXT:    sw a0, 44(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 545260
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -1967
+; ILP32E-WITHFP-NEXT:    sw a0, 40(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 964690
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -328
+; ILP32E-WITHFP-NEXT:    sw a0, 36(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 335544
+; ILP32E-WITHFP-NEXT:    addi a6, a0, 1311
+; ILP32E-WITHFP-NEXT:    lui a0, 688509
+; ILP32E-WITHFP-NEXT:    addi a5, a0, -2048
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 11
+; ILP32E-WITHFP-NEXT:    addi a2, sp, 32
+; ILP32E-WITHFP-NEXT:    li a3, 12
+; ILP32E-WITHFP-NEXT:    li a4, 13
+; ILP32E-WITHFP-NEXT:    sw a6, 32(sp)
+; ILP32E-WITHFP-NEXT:    call callee_aligned_stack@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -64
+; ILP32E-WITHFP-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 64
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_aligned_stack(i32 1, i32 11,
+    fp128 0xLEB851EB851EB851F400091EB851EB851, i32 12, i32 13,
+    i64 20000000000, i32 14, i32 15, double 2.720000e+00, i32 16,
+    [2 x i32] [i32 17, i32 18])
+  ret void
+}
+
+define double @callee_small_scalar_ret() {
+; ILP32E-FPELIM-LABEL: callee_small_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lui a1, 261888
+; ILP32E-FPELIM-NEXT:    li a0, 0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_small_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a1, 261888
+; ILP32E-WITHFP-NEXT:    li a0, 0
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  ret double 1.0
+}
+
+define i64 @caller_small_scalar_ret() {
+; ILP32E-FPELIM-LABEL: caller_small_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    call callee_small_scalar_ret@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_small_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    call callee_small_scalar_ret@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call double @callee_small_scalar_ret()
+  %2 = bitcast double %1 to i64
+  ret i64 %2
+}
+
+; Check that on RV32, i64 is passed in a pair of registers. Unlike
+; the convention for varargs, this need not be an aligned pair.
+
+define i32 @callee_i64_in_regs(i32 %a, i64 %b) {
+; ILP32E-FPELIM-LABEL: callee_i64_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_i64_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %b_trunc = trunc i64 %b to i32
+  %1 = add i32 %a, %b_trunc
+  ret i32 %1
+}
+
+define i32 @caller_i64_in_regs() {
+; ILP32E-FPELIM-LABEL: caller_i64_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    li a2, 0
+; ILP32E-FPELIM-NEXT:    call callee_i64_in_regs@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_i64_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    li a2, 0
+; ILP32E-WITHFP-NEXT:    call callee_i64_in_regs@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_i64_in_regs(i32 1, i64 2)
+  ret i32 %1
+}
+
+; Check that the stack is used once the GPRs are exhausted
+
+define i32 @callee_many_scalars(i8 %a, i16 %b, i32 %c, i64 %d, i32 %e, i32 %f, i64 %g, i32 %h) {
+; ILP32E-FPELIM-LABEL: callee_many_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a6, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a7, 0(sp)
+; ILP32E-FPELIM-NEXT:    lw t0, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw t1, 8(sp)
+; ILP32E-FPELIM-NEXT:    andi a0, a0, 255
+; ILP32E-FPELIM-NEXT:    slli a1, a1, 16
+; ILP32E-FPELIM-NEXT:    srli a1, a1, 16
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    add a0, a0, a2
+; ILP32E-FPELIM-NEXT:    xor a1, a4, t1
+; ILP32E-FPELIM-NEXT:    xor a2, a3, t0
+; ILP32E-FPELIM-NEXT:    or a1, a2, a1
+; ILP32E-FPELIM-NEXT:    seqz a1, a1
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    add a0, a0, a5
+; ILP32E-FPELIM-NEXT:    add a0, a0, a7
+; ILP32E-FPELIM-NEXT:    add a0, a0, a6
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_many_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a6, 12(s0)
+; ILP32E-WITHFP-NEXT:    lw a7, 0(s0)
+; ILP32E-WITHFP-NEXT:    lw t0, 4(s0)
+; ILP32E-WITHFP-NEXT:    lw t1, 8(s0)
+; ILP32E-WITHFP-NEXT:    andi a0, a0, 255
+; ILP32E-WITHFP-NEXT:    slli a1, a1, 16
+; ILP32E-WITHFP-NEXT:    srli a1, a1, 16
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    add a0, a0, a2
+; ILP32E-WITHFP-NEXT:    xor a1, a4, t1
+; ILP32E-WITHFP-NEXT:    xor a2, a3, t0
+; ILP32E-WITHFP-NEXT:    or a1, a2, a1
+; ILP32E-WITHFP-NEXT:    seqz a1, a1
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    add a0, a0, a5
+; ILP32E-WITHFP-NEXT:    add a0, a0, a7
+; ILP32E-WITHFP-NEXT:    add a0, a0, a6
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %a_ext = zext i8 %a to i32
+  %b_ext = zext i16 %b to i32
+  %1 = add i32 %a_ext, %b_ext
+  %2 = add i32 %1, %c
+  %3 = icmp eq i64 %d, %g
+  %4 = zext i1 %3 to i32
+  %5 = add i32 %4, %2
+  %6 = add i32 %5, %e
+  %7 = add i32 %6, %f
+  %8 = add i32 %7, %h
+  ret i32 %8
+}
+
+define i32 @caller_many_scalars() {
+; ILP32E-FPELIM-LABEL: caller_many_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -20
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 20
+; ILP32E-FPELIM-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 8
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 8(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 7
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a4, 6
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    li a2, 3
+; ILP32E-FPELIM-NEXT:    li a3, 4
+; ILP32E-FPELIM-NEXT:    li a5, 5
+; ILP32E-FPELIM-NEXT:    sw a4, 0(sp)
+; ILP32E-FPELIM-NEXT:    li a4, 0
+; ILP32E-FPELIM-NEXT:    call callee_many_scalars@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 20
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_many_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 8
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 8(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 7
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a4, 6
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    li a2, 3
+; ILP32E-WITHFP-NEXT:    li a3, 4
+; ILP32E-WITHFP-NEXT:    li a5, 5
+; ILP32E-WITHFP-NEXT:    sw a4, 0(sp)
+; ILP32E-WITHFP-NEXT:    li a4, 0
+; ILP32E-WITHFP-NEXT:    call callee_many_scalars@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 24
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_many_scalars(i8 1, i16 2, i32 3, i64 4, i32 5, i32 6, i64 7, i32 8)
+  ret i32 %1
+}
+
+; Check that i128 and fp128 are passed indirectly
+
+define i32 @callee_large_scalars(i128 %a, fp128 %b) {
+; ILP32E-FPELIM-LABEL: callee_large_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a2, 0(a1)
+; ILP32E-FPELIM-NEXT:    lw a3, 0(a0)
+; ILP32E-FPELIM-NEXT:    lw a4, 4(a1)
+; ILP32E-FPELIM-NEXT:    lw a5, 12(a1)
+; ILP32E-FPELIM-NEXT:    lw a6, 12(a0)
+; ILP32E-FPELIM-NEXT:    lw a7, 4(a0)
+; ILP32E-FPELIM-NEXT:    lw a1, 8(a1)
+; ILP32E-FPELIM-NEXT:    lw a0, 8(a0)
+; ILP32E-FPELIM-NEXT:    xor a5, a6, a5
+; ILP32E-FPELIM-NEXT:    xor a4, a7, a4
+; ILP32E-FPELIM-NEXT:    or a4, a4, a5
+; ILP32E-FPELIM-NEXT:    xor a0, a0, a1
+; ILP32E-FPELIM-NEXT:    xor a1, a3, a2
+; ILP32E-FPELIM-NEXT:    or a0, a1, a0
+; ILP32E-FPELIM-NEXT:    or a0, a0, a4
+; ILP32E-FPELIM-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a2, 0(a1)
+; ILP32E-WITHFP-NEXT:    lw a3, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw a4, 4(a1)
+; ILP32E-WITHFP-NEXT:    lw a5, 12(a1)
+; ILP32E-WITHFP-NEXT:    lw a6, 12(a0)
+; ILP32E-WITHFP-NEXT:    lw a7, 4(a0)
+; ILP32E-WITHFP-NEXT:    lw a1, 8(a1)
+; ILP32E-WITHFP-NEXT:    lw a0, 8(a0)
+; ILP32E-WITHFP-NEXT:    xor a5, a6, a5
+; ILP32E-WITHFP-NEXT:    xor a4, a7, a4
+; ILP32E-WITHFP-NEXT:    or a4, a4, a5
+; ILP32E-WITHFP-NEXT:    xor a0, a0, a1
+; ILP32E-WITHFP-NEXT:    xor a1, a3, a2
+; ILP32E-WITHFP-NEXT:    or a0, a1, a0
+; ILP32E-WITHFP-NEXT:    or a0, a0, a4
+; ILP32E-WITHFP-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %b_bitcast = bitcast fp128 %b to i128
+  %1 = icmp eq i128 %a, %b_bitcast
+  %2 = zext i1 %1 to i32
+  ret i32 %2
+}
+
+define i32 @caller_large_scalars() {
+; ILP32E-FPELIM-LABEL: caller_large_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -48
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 48
+; ILP32E-FPELIM-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 48
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    lui a0, 524272
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 8(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 4(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 0(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 36(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 32(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 28(sp)
+; ILP32E-FPELIM-NEXT:    li a2, 1
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 24
+; ILP32E-FPELIM-NEXT:    mv a1, sp
+; ILP32E-FPELIM-NEXT:    sw a2, 24(sp)
+; ILP32E-FPELIM-NEXT:    call callee_large_scalars@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -48
+; ILP32E-FPELIM-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 48
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 48
+; ILP32E-WITHFP-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 48
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    lui a0, 524272
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 8(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 4(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 0(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 36(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 32(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 28(sp)
+; ILP32E-WITHFP-NEXT:    li a2, 1
+; ILP32E-WITHFP-NEXT:    addi a0, sp, 24
+; ILP32E-WITHFP-NEXT:    mv a1, sp
+; ILP32E-WITHFP-NEXT:    sw a2, 24(sp)
+; ILP32E-WITHFP-NEXT:    call callee_large_scalars@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -48
+; ILP32E-WITHFP-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_large_scalars(i128 1, fp128 0xL00000000000000007FFF000000000000)
+  ret i32 %1
+}
+
+; Check that arguments larger than 2*xlen are handled correctly when their
+; address is passed on the stack rather than in memory
+
+; Must keep define on a single line due to an update_llc_test_checks.py limitation
+define i32 @callee_large_scalars_exhausted_regs(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i128 %h, i32 %i, fp128 %j) {
+; ILP32E-FPELIM-LABEL: callee_large_scalars_exhausted_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a2, 0(a0)
+; ILP32E-FPELIM-NEXT:    lw a3, 0(a1)
+; ILP32E-FPELIM-NEXT:    lw a4, 4(a0)
+; ILP32E-FPELIM-NEXT:    lw a5, 12(a0)
+; ILP32E-FPELIM-NEXT:    lw a6, 12(a1)
+; ILP32E-FPELIM-NEXT:    lw a7, 4(a1)
+; ILP32E-FPELIM-NEXT:    lw a0, 8(a0)
+; ILP32E-FPELIM-NEXT:    lw a1, 8(a1)
+; ILP32E-FPELIM-NEXT:    xor a5, a6, a5
+; ILP32E-FPELIM-NEXT:    xor a4, a7, a4
+; ILP32E-FPELIM-NEXT:    or a4, a4, a5
+; ILP32E-FPELIM-NEXT:    xor a0, a1, a0
+; ILP32E-FPELIM-NEXT:    xor a1, a3, a2
+; ILP32E-FPELIM-NEXT:    or a0, a1, a0
+; ILP32E-FPELIM-NEXT:    or a0, a0, a4
+; ILP32E-FPELIM-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_scalars_exhausted_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a0, 12(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    lw a2, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw a3, 0(a1)
+; ILP32E-WITHFP-NEXT:    lw a4, 4(a0)
+; ILP32E-WITHFP-NEXT:    lw a5, 12(a0)
+; ILP32E-WITHFP-NEXT:    lw a6, 12(a1)
+; ILP32E-WITHFP-NEXT:    lw a7, 4(a1)
+; ILP32E-WITHFP-NEXT:    lw a0, 8(a0)
+; ILP32E-WITHFP-NEXT:    lw a1, 8(a1)
+; ILP32E-WITHFP-NEXT:    xor a5, a6, a5
+; ILP32E-WITHFP-NEXT:    xor a4, a7, a4
+; ILP32E-WITHFP-NEXT:    or a4, a4, a5
+; ILP32E-WITHFP-NEXT:    xor a0, a1, a0
+; ILP32E-WITHFP-NEXT:    xor a1, a3, a2
+; ILP32E-WITHFP-NEXT:    or a0, a1, a0
+; ILP32E-WITHFP-NEXT:    or a0, a0, a4
+; ILP32E-WITHFP-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %j_bitcast = bitcast fp128 %j to i128
+  %1 = icmp eq i128 %h, %j_bitcast
+  %2 = zext i1 %1 to i32
+  ret i32 %2
+}
+
+define i32 @caller_large_scalars_exhausted_regs() {
+; ILP32E-FPELIM-LABEL: caller_large_scalars_exhausted_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-FPELIM-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 16
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 9
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 40
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 7
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 524272
+; ILP32E-FPELIM-NEXT:    sw a0, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 20(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 16(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 52(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 48(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 44(sp)
+; ILP32E-FPELIM-NEXT:    li a6, 8
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    li a2, 3
+; ILP32E-FPELIM-NEXT:    li a3, 4
+; ILP32E-FPELIM-NEXT:    li a4, 5
+; ILP32E-FPELIM-NEXT:    li a5, 6
+; ILP32E-FPELIM-NEXT:    sw a6, 40(sp)
+; ILP32E-FPELIM-NEXT:    call callee_large_scalars_exhausted_regs@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -64
+; ILP32E-FPELIM-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 64
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_scalars_exhausted_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-WITHFP-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    addi a0, sp, 16
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 9
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    addi a0, sp, 40
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 7
+; ILP32E-WITHFP-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 524272
+; ILP32E-WITHFP-NEXT:    sw a0, 28(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 24(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 20(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 16(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 52(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 48(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 44(sp)
+; ILP32E-WITHFP-NEXT:    li a6, 8
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    li a2, 3
+; ILP32E-WITHFP-NEXT:    li a3, 4
+; ILP32E-WITHFP-NEXT:    li a4, 5
+; ILP32E-WITHFP-NEXT:    li a5, 6
+; ILP32E-WITHFP-NEXT:    sw a6, 40(sp)
+; ILP32E-WITHFP-NEXT:    call callee_large_scalars_exhausted_regs@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -64
+; ILP32E-WITHFP-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 64
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_large_scalars_exhausted_regs(
+      i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i128 8, i32 9,
+      fp128 0xL00000000000000007FFF000000000000)
+  ret i32 %1
+}
+
+; Ensure that libcalls generated in the middle-end obey the calling convention
+
+define i32 @caller_mixed_scalar_libcalls(i64 %a) {
+; ILP32E-FPELIM-LABEL: caller_mixed_scalar_libcalls:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-FPELIM-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    mv a2, a1
+; ILP32E-FPELIM-NEXT:    mv a1, a0
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call __floatditf@plt
+; ILP32E-FPELIM-NEXT:    lw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -24
+; ILP32E-FPELIM-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 24
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_mixed_scalar_libcalls:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    mv a2, a1
+; ILP32E-WITHFP-NEXT:    mv a1, a0
+; ILP32E-WITHFP-NEXT:    mv a0, sp
+; ILP32E-WITHFP-NEXT:    call __floatditf@plt
+; ILP32E-WITHFP-NEXT:    lw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -24
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 24
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = sitofp i64 %a to fp128
+  %2 = bitcast fp128 %1 to i128
+  %3 = trunc i128 %2 to i32
+  ret i32 %3
+}
+
+
+; Check passing of coerced integer arrays
+
+%struct.small = type { i32, i32* }
+
+define i32 @callee_small_coerced_struct([2 x i32] %a.coerce) {
+; ILP32E-FPELIM-LABEL: callee_small_coerced_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    xor a0, a0, a1
+; ILP32E-FPELIM-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_small_coerced_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    xor a0, a0, a1
+; ILP32E-WITHFP-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = extractvalue [2 x i32] %a.coerce, 0
+  %2 = extractvalue [2 x i32] %a.coerce, 1
+  %3 = icmp eq i32 %1, %2
+  %4 = zext i1 %3 to i32
+  ret i32 %4
+}
+
+define i32 @caller_small_coerced_struct() {
+; ILP32E-FPELIM-LABEL: caller_small_coerced_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    call callee_small_coerced_struct@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_small_coerced_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    call callee_small_coerced_struct@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call i32 @callee_small_coerced_struct([2 x i32] [i32 1, i32 2])
+  ret i32 %1
+}
+
+; Check large struct arguments, which are passed byval
+
+%struct.large = type { i32, i32, i32, i32 }
+
+define i32 @callee_large_struct(%struct.large* byval(%struct.large) align 4 %a) {
+; ILP32E-FPELIM-LABEL: callee_large_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a1, 0(a0)
+; ILP32E-FPELIM-NEXT:    lw a0, 12(a0)
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a1, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw a0, 12(a0)
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 0
+  %2 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 3
+  %3 = load i32, i32* %1
+  %4 = load i32, i32* %2
+  %5 = add i32 %3, %4
+  ret i32 %5
+}
+
+define i32 @caller_large_struct() {
+; ILP32E-FPELIM-LABEL: caller_large_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -36
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 36
+; ILP32E-FPELIM-NEXT:    sw ra, 32(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    sw a0, 16(sp)
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    sw a1, 20(sp)
+; ILP32E-FPELIM-NEXT:    li a2, 3
+; ILP32E-FPELIM-NEXT:    sw a2, 24(sp)
+; ILP32E-FPELIM-NEXT:    li a3, 4
+; ILP32E-FPELIM-NEXT:    sw a3, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 8(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 12(sp)
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call callee_large_struct@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 32(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 36
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -40
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 40
+; ILP32E-WITHFP-NEXT:    sw ra, 36(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 32(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 40
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    sw a0, -24(s0)
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    sw a1, -20(s0)
+; ILP32E-WITHFP-NEXT:    li a2, 3
+; ILP32E-WITHFP-NEXT:    sw a2, -16(s0)
+; ILP32E-WITHFP-NEXT:    li a3, 4
+; ILP32E-WITHFP-NEXT:    sw a3, -12(s0)
+; ILP32E-WITHFP-NEXT:    sw a0, -40(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, -36(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, -32(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, -28(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, -40
+; ILP32E-WITHFP-NEXT:    call callee_large_struct@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 36(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 32(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 40
+; ILP32E-WITHFP-NEXT:    ret
+  %ls = alloca %struct.large, align 4
+  %1 = bitcast %struct.large* %ls to i8*
+  %a = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 0
+  store i32 1, i32* %a
+  %b = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 1
+  store i32 2, i32* %b
+  %c = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 2
+  store i32 3, i32* %c
+  %d = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 3
+  store i32 4, i32* %d
+  %2 = call i32 @callee_large_struct(%struct.large* byval(%struct.large) align 4 %ls)
+  ret i32 %2
+}
+
+; Check return of 2x xlen structs
+
+define %struct.small @callee_small_struct_ret() {
+; ILP32E-FPELIM-LABEL: callee_small_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_small_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  ret %struct.small { i32 1, i32* null }
+}
+
+define i32 @caller_small_struct_ret() {
+; ILP32E-FPELIM-LABEL: caller_small_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    call callee_small_struct_ret@plt
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_small_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    call callee_small_struct_ret@plt
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call %struct.small @callee_small_struct_ret()
+  %2 = extractvalue %struct.small %1, 0
+  %3 = extractvalue %struct.small %1, 1
+  %4 = ptrtoint i32* %3 to i32
+  %5 = add i32 %2, %4
+  ret i32 %5
+}
+
+; Check return of >2x xlen scalars
+
+define fp128 @callee_large_scalar_ret() {
+; ILP32E-FPELIM-LABEL: callee_large_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lui a1, 524272
+; ILP32E-FPELIM-NEXT:    sw a1, 12(a0)
+; ILP32E-FPELIM-NEXT:    sw zero, 8(a0)
+; ILP32E-FPELIM-NEXT:    sw zero, 4(a0)
+; ILP32E-FPELIM-NEXT:    sw zero, 0(a0)
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a1, 524272
+; ILP32E-WITHFP-NEXT:    sw a1, 12(a0)
+; ILP32E-WITHFP-NEXT:    sw zero, 8(a0)
+; ILP32E-WITHFP-NEXT:    sw zero, 4(a0)
+; ILP32E-WITHFP-NEXT:    sw zero, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  ret fp128 0xL00000000000000007FFF000000000000
+}
+
+define void @caller_large_scalar_ret() {
+; ILP32E-FPELIM-LABEL: caller_large_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 32
+; ILP32E-FPELIM-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 32
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call callee_large_scalar_ret@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -32
+; ILP32E-FPELIM-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -32
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 32
+; ILP32E-WITHFP-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 32
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    mv a0, sp
+; ILP32E-WITHFP-NEXT:    call callee_large_scalar_ret@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -32
+; ILP32E-WITHFP-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 32
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = call fp128 @callee_large_scalar_ret()
+  ret void
+}
+
+; Check return of >2x xlen structs
+
+define void @callee_large_struct_ret(%struct.large* noalias sret(%struct.large) %agg.result) {
+; ILP32E-FPELIM-LABEL: callee_large_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    li a1, 1
+; ILP32E-FPELIM-NEXT:    sw a1, 0(a0)
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    sw a1, 4(a0)
+; ILP32E-FPELIM-NEXT:    li a1, 3
+; ILP32E-FPELIM-NEXT:    sw a1, 8(a0)
+; ILP32E-FPELIM-NEXT:    li a1, 4
+; ILP32E-FPELIM-NEXT:    sw a1, 12(a0)
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a1, 1
+; ILP32E-WITHFP-NEXT:    sw a1, 0(a0)
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    sw a1, 4(a0)
+; ILP32E-WITHFP-NEXT:    li a1, 3
+; ILP32E-WITHFP-NEXT:    sw a1, 8(a0)
+; ILP32E-WITHFP-NEXT:    li a1, 4
+; ILP32E-WITHFP-NEXT:    sw a1, 12(a0)
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+  %a = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 0
+  store i32 1, i32* %a, align 4
+  %b = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 1
+  store i32 2, i32* %b, align 4
+  %c = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 2
+  store i32 3, i32* %c, align 4
+  %d = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 3
+  store i32 4, i32* %d, align 4
+  ret void
+}
+
+define i32 @caller_large_struct_ret() {
+; ILP32E-FPELIM-LABEL: caller_large_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-FPELIM-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call callee_large_struct_ret@plt
+; ILP32E-FPELIM-NEXT:    lw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -24
+; ILP32E-FPELIM-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 24
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    mv a0, sp
+; ILP32E-WITHFP-NEXT:    call callee_large_struct_ret@plt
+; ILP32E-WITHFP-NEXT:    lw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lw a1, 12(sp)
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -24
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 24
+; ILP32E-WITHFP-NEXT:    ret
+  %1 = alloca %struct.large
+  call void @callee_large_struct_ret(%struct.large* sret(%struct.large) %1)
+  %2 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 0
+  %3 = load i32, i32* %2
+  %4 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 3
+  %5 = load i32, i32* %4
+  %6 = add i32 %3, %5
+  ret i32 %6
+}
diff --git a/llvm/test/CodeGen/RISCV/calling-conv-rv32f-ilp32e.ll b/llvm/test/CodeGen/RISCV/calling-conv-rv32f-ilp32e.ll
new file mode 100644
index 000000000000..09a8d4d4e757
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/calling-conv-rv32f-ilp32e.ll
@@ -0,0 +1,83 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32IF-ILP32E
+
+; Exercises the ILP32E calling convention code in the case that f32 is a legal
+; type. As well as testing that lowering is correct, these tests also aim to
+; check that floating point load/store or integer load/store is chosen
+; optimally when floats are passed on the stack.
+
+define float @onstack_f32_noop(i64 %a, i64 %b, i64 %c, i64 %d, float %e, float %f) nounwind {
+; RV32IF-ILP32E-LABEL: onstack_f32_noop:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    lw a0, 12(sp)
+; RV32IF-ILP32E-NEXT:    ret
+  ret float %f
+}
+
+define float @onstack_f32_fadd(i64 %a, i64 %b, i64 %c, i64 %d, float %e, float %f) nounwind {
+; RV32IF-ILP32E-LABEL: onstack_f32_fadd:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    flw ft0, 12(sp)
+; RV32IF-ILP32E-NEXT:    flw ft1, 8(sp)
+; RV32IF-ILP32E-NEXT:    fadd.s ft0, ft1, ft0
+; RV32IF-ILP32E-NEXT:    fmv.x.w a0, ft0
+; RV32IF-ILP32E-NEXT:    ret
+  %1 = fadd float %e, %f
+  ret float %1
+}
+
+define float @caller_onstack_f32_noop(float %a) nounwind {
+; RV32IF-ILP32E-LABEL: caller_onstack_f32_noop:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    addi sp, sp, -20
+; RV32IF-ILP32E-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; RV32IF-ILP32E-NEXT:    sw a0, 12(sp)
+; RV32IF-ILP32E-NEXT:    lui a0, 264704
+; RV32IF-ILP32E-NEXT:    sw a0, 8(sp)
+; RV32IF-ILP32E-NEXT:    sw zero, 4(sp)
+; RV32IF-ILP32E-NEXT:    li a1, 4
+; RV32IF-ILP32E-NEXT:    li a0, 1
+; RV32IF-ILP32E-NEXT:    li a2, 2
+; RV32IF-ILP32E-NEXT:    li a4, 3
+; RV32IF-ILP32E-NEXT:    sw a1, 0(sp)
+; RV32IF-ILP32E-NEXT:    li a1, 0
+; RV32IF-ILP32E-NEXT:    li a3, 0
+; RV32IF-ILP32E-NEXT:    li a5, 0
+; RV32IF-ILP32E-NEXT:    call onstack_f32_noop@plt
+; RV32IF-ILP32E-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; RV32IF-ILP32E-NEXT:    addi sp, sp, 20
+; RV32IF-ILP32E-NEXT:    ret
+  %1 = call float @onstack_f32_noop(i64 1, i64 2, i64 3, i64 4, float 5.0, float %a)
+  ret float %1
+}
+
+define float @caller_onstack_f32_fadd(float %a, float %b) nounwind {
+; RV32IF-ILP32E-LABEL: caller_onstack_f32_fadd:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    addi sp, sp, -20
+; RV32IF-ILP32E-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; RV32IF-ILP32E-NEXT:    fmv.w.x ft0, a1
+; RV32IF-ILP32E-NEXT:    fmv.w.x ft1, a0
+; RV32IF-ILP32E-NEXT:    fadd.s ft2, ft1, ft0
+; RV32IF-ILP32E-NEXT:    fsub.s ft0, ft0, ft1
+; RV32IF-ILP32E-NEXT:    sw zero, 4(sp)
+; RV32IF-ILP32E-NEXT:    li a0, 4
+; RV32IF-ILP32E-NEXT:    sw a0, 0(sp)
+; RV32IF-ILP32E-NEXT:    fsw ft0, 12(sp)
+; RV32IF-ILP32E-NEXT:    li a0, 1
+; RV32IF-ILP32E-NEXT:    li a2, 2
+; RV32IF-ILP32E-NEXT:    li a4, 3
+; RV32IF-ILP32E-NEXT:    fsw ft2, 8(sp)
+; RV32IF-ILP32E-NEXT:    li a1, 0
+; RV32IF-ILP32E-NEXT:    li a3, 0
+; RV32IF-ILP32E-NEXT:    li a5, 0
+; RV32IF-ILP32E-NEXT:    call onstack_f32_noop@plt
+; RV32IF-ILP32E-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; RV32IF-ILP32E-NEXT:    addi sp, sp, 20
+; RV32IF-ILP32E-NEXT:    ret
+  %1 = fadd float %a, %b
+  %2 = fsub float %b, %a
+  %3 = call float @onstack_f32_noop(i64 1, i64 2, i64 3, i64 4, float %1, float %2)
+  ret float %3
+}
diff --git a/llvm/test/CodeGen/RISCV/rv32e.ll b/llvm/test/CodeGen/RISCV/rv32e.ll
index 88379ab43872..d741cf4c73a6 100644
--- a/llvm/test/CodeGen/RISCV/rv32e.ll
+++ b/llvm/test/CodeGen/RISCV/rv32e.ll
@@ -1,7 +1,24 @@
-; RUN: not --crash llc -mtriple=riscv32 -mattr=+e < %s 2>&1 | FileCheck %s
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -mattr=+e < %s 2>&1 | FileCheck %s
 
-; CHECK: LLVM ERROR: Codegen not yet implemented for RV32E
+; TODO: Add more tests.
 
-define void @nothing() nounwind {
-  ret void
+define i32 @exhausted(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g) {
+; CHECK-LABEL: exhausted:
+; CHECK:       # %bb.0:
+; CHECK-NEXT:    lw t0, 0(sp)
+; CHECK-NEXT:    add a0, a0, a1
+; CHECK-NEXT:    add a0, a2, a0
+; CHECK-NEXT:    add a0, a3, a0
+; CHECK-NEXT:    add a0, a4, a0
+; CHECK-NEXT:    add a0, a5, a0
+; CHECK-NEXT:    add a0, t0, a0
+; CHECK-NEXT:    ret
+  %1 = add i32 %a, %b
+  %2 = add i32 %c, %1
+  %3 = add i32 %d, %2
+  %4 = add i32 %e, %3
+  %5 = add i32 %f, %4
+  %6 = add i32 %g, %5
+  ret i32 %6
 }
diff --git a/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll b/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll
index 5bfa08a2201a..389c54150eb6 100644
--- a/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll
+++ b/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll
@@ -1,6 +1,8 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32I-ILP32E
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV64I
 
@@ -34,6 +36,33 @@ define void @caller(i32 %n) {
 ; RV32I-NEXT:    addi sp, sp, 64
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 64
+; RV32I-ILP32E-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s1, 52(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    .cfi_offset s1, -12
+; RV32I-ILP32E-NEXT:    addi s0, sp, 64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -64
+; RV32I-ILP32E-NEXT:    mv s1, sp
+; RV32I-ILP32E-NEXT:    addi a0, a0, 3
+; RV32I-ILP32E-NEXT:    andi a0, a0, -4
+; RV32I-ILP32E-NEXT:    sub a0, sp, a0
+; RV32I-ILP32E-NEXT:    mv sp, a0
+; RV32I-ILP32E-NEXT:    mv a1, s1
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -64
+; RV32I-ILP32E-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s1, 52(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 64
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -64
diff --git a/llvm/test/CodeGen/RISCV/stack-realignment.ll b/llvm/test/CodeGen/RISCV/stack-realignment.ll
index 8d6d09763649..f50b54857a68 100644
--- a/llvm/test/CodeGen/RISCV/stack-realignment.ll
+++ b/llvm/test/CodeGen/RISCV/stack-realignment.ll
@@ -1,11 +1,102 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32I-ILP32E
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV64I
 
 declare void @callee(i8*)
 
+define void @caller16() {
+; RV32I-LABEL: caller16:
+; RV32I:       # %bb.0:
+; RV32I-NEXT:    addi sp, sp, -16
+; RV32I-NEXT:    .cfi_def_cfa_offset 16
+; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-NEXT:    .cfi_offset ra, -4
+; RV32I-NEXT:    mv a0, sp
+; RV32I-NEXT:    call callee@plt
+; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-NEXT:    addi sp, sp, 16
+; RV32I-NEXT:    ret
+;
+; RV32I-ILP32E-LABEL: caller16:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -16
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 16
+; RV32I-ILP32E-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 16
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -16
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -16
+; RV32I-ILP32E-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 16
+; RV32I-ILP32E-NEXT:    ret
+;
+; RV64I-LABEL: caller16:
+; RV64I:       # %bb.0:
+; RV64I-NEXT:    addi sp, sp, -16
+; RV64I-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-NEXT:    .cfi_offset ra, -8
+; RV64I-NEXT:    mv a0, sp
+; RV64I-NEXT:    call callee@plt
+; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-NEXT:    addi sp, sp, 16
+; RV64I-NEXT:    ret
+  %1 = alloca i8, align 16
+  call void @callee(i8* %1)
+  ret void
+}
+
+define void @caller_no_realign16() "no-realign-stack" {
+; RV32I-LABEL: caller_no_realign16:
+; RV32I:       # %bb.0:
+; RV32I-NEXT:    addi sp, sp, -16
+; RV32I-NEXT:    .cfi_def_cfa_offset 16
+; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-NEXT:    .cfi_offset ra, -4
+; RV32I-NEXT:    mv a0, sp
+; RV32I-NEXT:    call callee@plt
+; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-NEXT:    addi sp, sp, 16
+; RV32I-NEXT:    ret
+;
+; RV32I-ILP32E-LABEL: caller_no_realign16:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
+; RV64I-LABEL: caller_no_realign16:
+; RV64I:       # %bb.0:
+; RV64I-NEXT:    addi sp, sp, -16
+; RV64I-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-NEXT:    .cfi_offset ra, -8
+; RV64I-NEXT:    mv a0, sp
+; RV64I-NEXT:    call callee@plt
+; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-NEXT:    addi sp, sp, 16
+; RV64I-NEXT:    ret
+  %1 = alloca i8, align 16
+  call void @callee(i8* %1)
+  ret void
+}
+
 define void @caller32() {
 ; RV32I-LABEL: caller32:
 ; RV32I:       # %bb.0:
@@ -26,6 +117,25 @@ define void @caller32() {
 ; RV32I-NEXT:    addi sp, sp, 32
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller32:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -32
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 32
+; RV32I-ILP32E-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 32
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -32
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -32
+; RV32I-ILP32E-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 32
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller32:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -32
@@ -62,6 +172,18 @@ define void @caller_no_realign32() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign32:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign32:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -98,6 +220,25 @@ define void @caller64() {
 ; RV32I-NEXT:    addi sp, sp, 64
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller64:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 64
+; RV32I-ILP32E-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -64
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -64
+; RV32I-ILP32E-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 64
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller64:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -64
@@ -134,6 +275,18 @@ define void @caller_no_realign64() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign64:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign64:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -170,6 +323,25 @@ define void @caller128() {
 ; RV32I-NEXT:    addi sp, sp, 128
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller128:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -128
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 128
+; RV32I-ILP32E-NEXT:    sw ra, 124(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 120(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 128
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -128
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -128
+; RV32I-ILP32E-NEXT:    lw ra, 124(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 120(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 128
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller128:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -128
@@ -206,6 +378,18 @@ define void @caller_no_realign128() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign128:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign128:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -242,6 +426,25 @@ define void @caller256() {
 ; RV32I-NEXT:    addi sp, sp, 256
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller256:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -256
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 256
+; RV32I-ILP32E-NEXT:    sw ra, 252(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 248(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 256
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -256
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -256
+; RV32I-ILP32E-NEXT:    lw ra, 252(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 248(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 256
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller256:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -256
@@ -278,6 +481,18 @@ define void @caller_no_realign256() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign256:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign256:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -314,6 +529,25 @@ define void @caller512() {
 ; RV32I-NEXT:    addi sp, sp, 1024
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller512:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -1024
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 1024
+; RV32I-ILP32E-NEXT:    sw ra, 1020(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 1016(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 1024
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -512
+; RV32I-ILP32E-NEXT:    addi a0, sp, 512
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -1024
+; RV32I-ILP32E-NEXT:    lw ra, 1020(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 1016(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 1024
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller512:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -1024
@@ -350,6 +584,18 @@ define void @caller_no_realign512() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign512:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign512:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -388,6 +634,27 @@ define void @caller1024() {
 ; RV32I-NEXT:    addi sp, sp, 2032
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller1024:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 2044
+; RV32I-ILP32E-NEXT:    sw ra, 2040(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 2036(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    addi sp, sp, -4
+; RV32I-ILP32E-NEXT:    andi sp, sp, -1024
+; RV32I-ILP32E-NEXT:    addi a0, sp, 1024
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -2048
+; RV32I-ILP32E-NEXT:    addi sp, sp, 4
+; RV32I-ILP32E-NEXT:    lw ra, 2040(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 2036(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 2044
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller1024:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -2032
@@ -426,6 +693,18 @@ define void @caller_no_realign1024() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign1024:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign1024:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -471,6 +750,34 @@ define void @caller2048() {
 ; RV32I-NEXT:    addi sp, sp, 2032
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller2048:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 2044
+; RV32I-ILP32E-NEXT:    sw ra, 2040(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 2036(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    lui a0, 1
+; RV32I-ILP32E-NEXT:    addi a0, a0, -2044
+; RV32I-ILP32E-NEXT:    sub sp, sp, a0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -2048
+; RV32I-ILP32E-NEXT:    lui a0, 1
+; RV32I-ILP32E-NEXT:    addi a0, a0, -2048
+; RV32I-ILP32E-NEXT:    add a0, sp, a0
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lui a0, 1
+; RV32I-ILP32E-NEXT:    sub sp, s0, a0
+; RV32I-ILP32E-NEXT:    lui a0, 1
+; RV32I-ILP32E-NEXT:    addi a0, a0, -2044
+; RV32I-ILP32E-NEXT:    add sp, sp, a0
+; RV32I-ILP32E-NEXT:    lw ra, 2040(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 2036(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 2044
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller2048:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -2032
@@ -516,6 +823,18 @@ define void @caller_no_realign2048() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign2048:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign2048:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -561,6 +880,34 @@ define void @caller4096() {
 ; RV32I-NEXT:    addi sp, sp, 2032
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller4096:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 2044
+; RV32I-ILP32E-NEXT:    sw ra, 2040(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 2036(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    lui a0, 2
+; RV32I-ILP32E-NEXT:    addi a0, a0, -2044
+; RV32I-ILP32E-NEXT:    sub sp, sp, a0
+; RV32I-ILP32E-NEXT:    srli a0, sp, 12
+; RV32I-ILP32E-NEXT:    slli sp, a0, 12
+; RV32I-ILP32E-NEXT:    lui a0, 1
+; RV32I-ILP32E-NEXT:    add a0, sp, a0
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lui a0, 2
+; RV32I-ILP32E-NEXT:    sub sp, s0, a0
+; RV32I-ILP32E-NEXT:    lui a0, 2
+; RV32I-ILP32E-NEXT:    addi a0, a0, -2044
+; RV32I-ILP32E-NEXT:    add sp, sp, a0
+; RV32I-ILP32E-NEXT:    lw ra, 2040(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 2036(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 2044
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller4096:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -2032
@@ -606,6 +953,18 @@ define void @caller_no_realign4096() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign4096:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign4096:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
diff --git a/llvm/test/CodeGen/RISCV/target-abi-valid.ll b/llvm/test/CodeGen/RISCV/target-abi-valid.ll
index 2d4079601f7b..5c03208825d1 100644
--- a/llvm/test/CodeGen/RISCV/target-abi-valid.ll
+++ b/llvm/test/CodeGen/RISCV/target-abi-valid.ll
@@ -2,6 +2,8 @@
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv32 -target-abi ilp32 < %s \
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e < %s 2>&1 \
+; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32 < %s \
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv32 -mattr=+d -target-abi ilp32 < %s \
@@ -33,8 +35,3 @@ define void @nothing() nounwind {
 ; CHECK-IMP-NEXT:    ret
   ret void
 }
-
-; RUN: not --crash llc -mtriple=riscv32 -target-abi ilp32e < %s 2>&1 \
-; RUN:   | FileCheck -check-prefix=CHECK-UNIMP %s
-
-; CHECK-UNIMP: LLVM ERROR: Don't know how to lower this ABI
diff --git a/llvm/test/CodeGen/RISCV/vararg-ilp32e.ll b/llvm/test/CodeGen/RISCV/vararg-ilp32e.ll
new file mode 100644
index 000000000000..eff8978559d0
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/vararg-ilp32e.ll
@@ -0,0 +1,146 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -frame-pointer=all -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-WITHFP %s
+
+declare void @llvm.va_start(i8*)
+declare void @llvm.va_end(i8*)
+declare void @abort()
+
+define i32 @caller(i32 %a) {
+; ILP32E-LABEL: caller:
+; ILP32E:       # %bb.0: # %entry
+; ILP32E-NEXT:    addi sp, sp, -8
+; ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    .cfi_offset ra, -4
+; ILP32E-NEXT:    .cfi_offset s0, -8
+; ILP32E-NEXT:    mv s0, a0
+; ILP32E-NEXT:    li a0, 1
+; ILP32E-NEXT:    lui a2, 262144
+; ILP32E-NEXT:    li a1, 0
+; ILP32E-NEXT:    call va_double@plt
+; ILP32E-NEXT:    mv a0, s0
+; ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    addi sp, sp, 8
+; ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller:
+; ILP32E-WITHFP:       # %bb.0: # %entry
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    mv s1, a0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    lui a2, 262144
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call va_double@plt
+; ILP32E-WITHFP-NEXT:    mv a0, s1
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 12
+; ILP32E-WITHFP-NEXT:    ret
+entry:
+  call void (i32, ...) @va_double(i32 1, double 2.000000e+00)
+  ret i32 %a
+}
+
+define void @va_double(i32 %n, ...) {
+; ILP32E-LABEL: va_double:
+; ILP32E:       # %bb.0: # %entry
+; ILP32E-NEXT:    addi sp, sp, -32
+; ILP32E-NEXT:    .cfi_def_cfa_offset 32
+; ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    .cfi_offset ra, -28
+; ILP32E-NEXT:    sw a5, 28(sp)
+; ILP32E-NEXT:    sw a4, 24(sp)
+; ILP32E-NEXT:    sw a3, 20(sp)
+; ILP32E-NEXT:    sw a2, 16(sp)
+; ILP32E-NEXT:    sw a1, 12(sp)
+; ILP32E-NEXT:    addi a0, sp, 19
+; ILP32E-NEXT:    andi a1, a0, -8
+; ILP32E-NEXT:    addi a0, a1, 8
+; ILP32E-NEXT:    sw a0, 0(sp)
+; ILP32E-NEXT:    lw a0, 0(a1)
+; ILP32E-NEXT:    ori a1, a1, 4
+; ILP32E-NEXT:    lw a1, 0(a1)
+; ILP32E-NEXT:    lui a3, 262144
+; ILP32E-NEXT:    li a2, 0
+; ILP32E-NEXT:    call __eqdf2@plt
+; ILP32E-NEXT:    bnez a0, .LBB1_2
+; ILP32E-NEXT:  # %bb.1: # %if.end
+; ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    addi sp, sp, 32
+; ILP32E-NEXT:    ret
+; ILP32E-NEXT:  .LBB1_2: # %if.then
+; ILP32E-NEXT:    call abort@plt
+;
+; ILP32E-WITHFP-LABEL: va_double:
+; ILP32E-WITHFP:       # %bb.0: # %entry
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -36
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 36
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -28
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -32
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 24
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a1, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a0, a1, 8
+; ILP32E-WITHFP-NEXT:    sw a0, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a1)
+; ILP32E-WITHFP-NEXT:    ori a1, a1, 4
+; ILP32E-WITHFP-NEXT:    lw a1, 0(a1)
+; ILP32E-WITHFP-NEXT:    lui a3, 262144
+; ILP32E-WITHFP-NEXT:    li a2, 0
+; ILP32E-WITHFP-NEXT:    call __eqdf2@plt
+; ILP32E-WITHFP-NEXT:    bnez a0, .LBB1_2
+; ILP32E-WITHFP-NEXT:  # %bb.1: # %if.end
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 36
+; ILP32E-WITHFP-NEXT:    ret
+; ILP32E-WITHFP-NEXT:  .LBB1_2: # %if.then
+; ILP32E-WITHFP-NEXT:    call abort@plt
+entry:
+  %args = alloca i8*, align 4
+  %args1 = bitcast i8** %args to i8*
+  call void @llvm.va_start(i8* %args1)
+  %argp.cur = load i8*, i8** %args, align 4
+  %0 = ptrtoint i8* %argp.cur to i32
+  %1 = add i32 %0, 7
+  %2 = and i32 %1, -8
+  %argp.cur.aligned = inttoptr i32 %2 to i8*
+  %argp.next = getelementptr inbounds i8, i8* %argp.cur.aligned, i32 8
+  store i8* %argp.next, i8** %args, align 4
+  %3 = bitcast i8* %argp.cur.aligned to double*
+  %4 = load double, double* %3, align 8
+  %cmp = fcmp une double %4, 2.000000e+00
+  br i1 %cmp, label %if.then, label %if.end
+
+if.then:
+  call void @abort()
+  unreachable
+
+if.end:
+  %args2 = bitcast i8** %args to i8*
+  call void @llvm.va_end(i8* %args2)
+  ret void
+}
diff --git a/llvm/test/CodeGen/RISCV/vararg.ll b/llvm/test/CodeGen/RISCV/vararg.ll
index 7ef595344faf..7f4b2ffa0b13 100644
--- a/llvm/test/CodeGen/RISCV/vararg.ll
+++ b/llvm/test/CodeGen/RISCV/vararg.ll
@@ -11,6 +11,10 @@
 ; RUN: llc -mtriple=riscv32 -mattr=+d -target-abi ilp32d \
 ; RUN:     -verify-machineinstrs < %s \
 ; RUN:   | FileCheck -check-prefix=RV32D-ILP32-ILP32F-ILP32D-FPELIM %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=RV32I-ILP32E %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -frame-pointer=all -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-WITHFP %s
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck -check-prefix=LP64-LP64F-LP64D-FPELIM %s
 ; RUN: llc -mtriple=riscv64 -mattr=+d -target-abi lp64f \
@@ -97,6 +101,44 @@ define i32 @va1(i8* %fmt, ...) {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va1:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -28
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 28
+; RV32I-ILP32E-NEXT:    mv a0, a1
+; RV32I-ILP32E-NEXT:    sw a5, 24(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 20(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 16(sp)
+; RV32I-ILP32E-NEXT:    sw a2, 12(sp)
+; RV32I-ILP32E-NEXT:    sw a1, 8(sp)
+; RV32I-ILP32E-NEXT:    addi a1, sp, 12
+; RV32I-ILP32E-NEXT:    sw a1, 0(sp)
+; RV32I-ILP32E-NEXT:    addi sp, sp, 28
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -36
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 36
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -28
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -32
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 24
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 36
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -204,6 +246,39 @@ define i32 @va1_va_arg(i8* %fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va1_va_arg:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -28
+; RV32I-ILP32E-NEXT:    mv a0, a1
+; RV32I-ILP32E-NEXT:    sw a5, 24(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 20(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 16(sp)
+; RV32I-ILP32E-NEXT:    sw a2, 12(sp)
+; RV32I-ILP32E-NEXT:    sw a1, 8(sp)
+; RV32I-ILP32E-NEXT:    addi a1, sp, 12
+; RV32I-ILP32E-NEXT:    sw a1, 0(sp)
+; RV32I-ILP32E-NEXT:    addi sp, sp, 28
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1_va_arg:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -36
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 36
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1_va_arg:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -341,6 +416,62 @@ define i32 @va1_va_arg_alloca(i8* %fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va1_va_arg_alloca:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -40
+; RV32I-ILP32E-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    addi s0, sp, 16
+; RV32I-ILP32E-NEXT:    mv s1, a1
+; RV32I-ILP32E-NEXT:    sw a5, 20(s0)
+; RV32I-ILP32E-NEXT:    sw a4, 16(s0)
+; RV32I-ILP32E-NEXT:    sw a3, 12(s0)
+; RV32I-ILP32E-NEXT:    sw a2, 8(s0)
+; RV32I-ILP32E-NEXT:    sw a1, 4(s0)
+; RV32I-ILP32E-NEXT:    addi a0, s0, 8
+; RV32I-ILP32E-NEXT:    sw a0, -16(s0)
+; RV32I-ILP32E-NEXT:    addi a0, a1, 3
+; RV32I-ILP32E-NEXT:    andi a0, a0, -4
+; RV32I-ILP32E-NEXT:    sub a0, sp, a0
+; RV32I-ILP32E-NEXT:    mv sp, a0
+; RV32I-ILP32E-NEXT:    call notdead@plt
+; RV32I-ILP32E-NEXT:    mv a0, s1
+; RV32I-ILP32E-NEXT:    addi sp, s0, -16
+; RV32I-ILP32E-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 40
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1_va_arg_alloca:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -40
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    mv s1, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a0, -16(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, a1, 3
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    sub a0, sp, a0
+; ILP32E-WITHFP-NEXT:    mv sp, a0
+; ILP32E-WITHFP-NEXT:    call notdead@plt
+; ILP32E-WITHFP-NEXT:    mv a0, s1
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -16
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 40
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1_va_arg_alloca:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -96
@@ -455,6 +586,33 @@ define void @va1_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 16
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va1_caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -4
+; RV32I-ILP32E-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lui a2, 261888
+; RV32I-ILP32E-NEXT:    li a3, 2
+; RV32I-ILP32E-NEXT:    li a1, 0
+; RV32I-ILP32E-NEXT:    call va1@plt
+; RV32I-ILP32E-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 4
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    lui a2, 261888
+; ILP32E-WITHFP-NEXT:    li a3, 2
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call va1@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -16
@@ -554,6 +712,47 @@ define i64 @va2(i8 *%fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va2:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -28
+; RV32I-ILP32E-NEXT:    sw a5, 24(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 20(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 16(sp)
+; RV32I-ILP32E-NEXT:    sw a2, 12(sp)
+; RV32I-ILP32E-NEXT:    sw a1, 8(sp)
+; RV32I-ILP32E-NEXT:    addi a0, sp, 15
+; RV32I-ILP32E-NEXT:    andi a1, a0, -8
+; RV32I-ILP32E-NEXT:    addi a0, sp, 23
+; RV32I-ILP32E-NEXT:    sw a0, 0(sp)
+; RV32I-ILP32E-NEXT:    lw a0, 0(a1)
+; RV32I-ILP32E-NEXT:    ori a1, a1, 4
+; RV32I-ILP32E-NEXT:    lw a1, 0(a1)
+; RV32I-ILP32E-NEXT:    addi sp, sp, 28
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va2:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -36
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a1, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 19
+; ILP32E-WITHFP-NEXT:    sw a0, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a1)
+; ILP32E-WITHFP-NEXT:    ori a1, a1, 4
+; ILP32E-WITHFP-NEXT:    lw a1, 0(a1)
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 36
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va2:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -696,6 +895,49 @@ define i64 @va2_va_arg(i8 *%fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va2_va_arg:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -28
+; RV32I-ILP32E-NEXT:    sw a5, 24(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 20(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 16(sp)
+; RV32I-ILP32E-NEXT:    sw a2, 12(sp)
+; RV32I-ILP32E-NEXT:    sw a1, 8(sp)
+; RV32I-ILP32E-NEXT:    addi a0, sp, 15
+; RV32I-ILP32E-NEXT:    andi a1, a0, -8
+; RV32I-ILP32E-NEXT:    ori a2, a1, 4
+; RV32I-ILP32E-NEXT:    sw a2, 0(sp)
+; RV32I-ILP32E-NEXT:    lw a0, 0(a1)
+; RV32I-ILP32E-NEXT:    addi a1, a1, 8
+; RV32I-ILP32E-NEXT:    sw a1, 0(sp)
+; RV32I-ILP32E-NEXT:    lw a1, 0(a2)
+; RV32I-ILP32E-NEXT:    addi sp, sp, 28
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va2_va_arg:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -36
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a1, a0, -8
+; ILP32E-WITHFP-NEXT:    ori a2, a1, 4
+; ILP32E-WITHFP-NEXT:    sw a2, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a1)
+; ILP32E-WITHFP-NEXT:    addi a1, a1, 8
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 0(a2)
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 36
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va2_va_arg:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -778,6 +1020,31 @@ define void @va2_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 16
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va2_caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -4
+; RV32I-ILP32E-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lui a2, 261888
+; RV32I-ILP32E-NEXT:    li a1, 0
+; RV32I-ILP32E-NEXT:    call va2@plt
+; RV32I-ILP32E-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 4
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va2_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    lui a2, 261888
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call va2@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va2_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -16
@@ -881,6 +1148,51 @@ define i64 @va3(i32 %a, i64 %b, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 32
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va3:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -20
+; RV32I-ILP32E-NEXT:    sw a5, 16(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 12(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 8(sp)
+; RV32I-ILP32E-NEXT:    addi a0, sp, 15
+; RV32I-ILP32E-NEXT:    andi a0, a0, -8
+; RV32I-ILP32E-NEXT:    addi a3, sp, 23
+; RV32I-ILP32E-NEXT:    sw a3, 0(sp)
+; RV32I-ILP32E-NEXT:    lw a3, 0(a0)
+; RV32I-ILP32E-NEXT:    ori a0, a0, 4
+; RV32I-ILP32E-NEXT:    lw a4, 0(a0)
+; RV32I-ILP32E-NEXT:    add a0, a1, a3
+; RV32I-ILP32E-NEXT:    sltu a1, a0, a1
+; RV32I-ILP32E-NEXT:    add a2, a2, a4
+; RV32I-ILP32E-NEXT:    add a1, a2, a1
+; RV32I-ILP32E-NEXT:    addi sp, sp, 20
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va3:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -28
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    sw a5, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a3, s0, 19
+; ILP32E-WITHFP-NEXT:    sw a3, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a3, 0(a0)
+; ILP32E-WITHFP-NEXT:    ori a0, a0, 4
+; ILP32E-WITHFP-NEXT:    lw a4, 0(a0)
+; ILP32E-WITHFP-NEXT:    add a0, a1, a3
+; ILP32E-WITHFP-NEXT:    sltu a1, a0, a1
+; ILP32E-WITHFP-NEXT:    add a2, a2, a4
+; ILP32E-WITHFP-NEXT:    add a1, a2, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 28
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va3:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -64
@@ -1030,6 +1342,53 @@ define i64 @va3_va_arg(i32 %a, i64 %b, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va3_va_arg:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -20
+; RV32I-ILP32E-NEXT:    sw a5, 16(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 12(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 8(sp)
+; RV32I-ILP32E-NEXT:    addi a0, sp, 15
+; RV32I-ILP32E-NEXT:    andi a0, a0, -8
+; RV32I-ILP32E-NEXT:    ori a3, a0, 4
+; RV32I-ILP32E-NEXT:    sw a3, 0(sp)
+; RV32I-ILP32E-NEXT:    lw a4, 0(a0)
+; RV32I-ILP32E-NEXT:    addi a0, a0, 8
+; RV32I-ILP32E-NEXT:    sw a0, 0(sp)
+; RV32I-ILP32E-NEXT:    lw a3, 0(a3)
+; RV32I-ILP32E-NEXT:    add a0, a1, a4
+; RV32I-ILP32E-NEXT:    sltu a1, a0, a1
+; RV32I-ILP32E-NEXT:    add a2, a2, a3
+; RV32I-ILP32E-NEXT:    add a1, a2, a1
+; RV32I-ILP32E-NEXT:    addi sp, sp, 20
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va3_va_arg:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -28
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    sw a5, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -8
+; ILP32E-WITHFP-NEXT:    ori a3, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a3, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a4, 0(a0)
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 8
+; ILP32E-WITHFP-NEXT:    sw a0, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a3, 0(a3)
+; ILP32E-WITHFP-NEXT:    add a0, a1, a4
+; ILP32E-WITHFP-NEXT:    sltu a1, a0, a1
+; ILP32E-WITHFP-NEXT:    add a2, a2, a3
+; ILP32E-WITHFP-NEXT:    add a1, a2, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 28
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va3_va_arg:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -64
@@ -1120,6 +1479,37 @@ define void @va3_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 16
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va3_caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -4
+; RV32I-ILP32E-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    li a0, 2
+; RV32I-ILP32E-NEXT:    li a1, 1111
+; RV32I-ILP32E-NEXT:    lui a4, 262144
+; RV32I-ILP32E-NEXT:    li a2, 0
+; RV32I-ILP32E-NEXT:    li a3, 0
+; RV32I-ILP32E-NEXT:    call va3@plt
+; RV32I-ILP32E-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 4
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va3_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    li a0, 2
+; ILP32E-WITHFP-NEXT:    li a1, 1111
+; ILP32E-WITHFP-NEXT:    lui a4, 262144
+; ILP32E-WITHFP-NEXT:    li a2, 0
+; ILP32E-WITHFP-NEXT:    li a3, 0
+; ILP32E-WITHFP-NEXT:    call va3@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va3_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -16
@@ -1281,6 +1671,87 @@ define i32 @va4_va_copy(i32 %argno, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va4_va_copy:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -40
+; RV32I-ILP32E-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    mv s0, a1
+; RV32I-ILP32E-NEXT:    sw a5, 36(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 32(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 28(sp)
+; RV32I-ILP32E-NEXT:    sw a2, 24(sp)
+; RV32I-ILP32E-NEXT:    sw a1, 20(sp)
+; RV32I-ILP32E-NEXT:    addi a0, sp, 24
+; RV32I-ILP32E-NEXT:    sw a0, 4(sp)
+; RV32I-ILP32E-NEXT:    sw a0, 0(sp)
+; RV32I-ILP32E-NEXT:    call notdead@plt
+; RV32I-ILP32E-NEXT:    lw a0, 4(sp)
+; RV32I-ILP32E-NEXT:    addi a0, a0, 3
+; RV32I-ILP32E-NEXT:    andi a0, a0, -4
+; RV32I-ILP32E-NEXT:    addi a1, a0, 4
+; RV32I-ILP32E-NEXT:    sw a1, 4(sp)
+; RV32I-ILP32E-NEXT:    lw a1, 0(a0)
+; RV32I-ILP32E-NEXT:    addi a0, a0, 7
+; RV32I-ILP32E-NEXT:    andi a0, a0, -4
+; RV32I-ILP32E-NEXT:    addi a2, a0, 4
+; RV32I-ILP32E-NEXT:    sw a2, 4(sp)
+; RV32I-ILP32E-NEXT:    lw a2, 0(a0)
+; RV32I-ILP32E-NEXT:    addi a0, a0, 7
+; RV32I-ILP32E-NEXT:    andi a0, a0, -4
+; RV32I-ILP32E-NEXT:    addi a3, a0, 4
+; RV32I-ILP32E-NEXT:    sw a3, 4(sp)
+; RV32I-ILP32E-NEXT:    lw a0, 0(a0)
+; RV32I-ILP32E-NEXT:    add a1, a1, s0
+; RV32I-ILP32E-NEXT:    add a1, a1, a2
+; RV32I-ILP32E-NEXT:    add a0, a1, a0
+; RV32I-ILP32E-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 40
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va4_va_copy:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -44
+; ILP32E-WITHFP-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 20
+; ILP32E-WITHFP-NEXT:    mv s1, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a0, -16(s0)
+; ILP32E-WITHFP-NEXT:    sw a0, -20(s0)
+; ILP32E-WITHFP-NEXT:    call notdead@plt
+; ILP32E-WITHFP-NEXT:    lw a0, -16(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 3
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    addi a1, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a1, -16(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 0(a0)
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 7
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    addi a2, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a2, -16(s0)
+; ILP32E-WITHFP-NEXT:    lw a2, 0(a0)
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 7
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    addi a3, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a3, -16(s0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a0)
+; ILP32E-WITHFP-NEXT:    add a1, a1, s1
+; ILP32E-WITHFP-NEXT:    add a1, a1, a2
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 44
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va4_va_copy:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -96
@@ -1524,6 +1995,104 @@ define void @va5_aligned_stack_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 64
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va5_aligned_stack_caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -64
+; RV32I-ILP32E-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    addi s0, sp, 64
+; RV32I-ILP32E-NEXT:    andi sp, sp, -16
+; RV32I-ILP32E-NEXT:    li a0, 17
+; RV32I-ILP32E-NEXT:    sw a0, 24(sp)
+; RV32I-ILP32E-NEXT:    li a0, 16
+; RV32I-ILP32E-NEXT:    sw a0, 20(sp)
+; RV32I-ILP32E-NEXT:    li a0, 15
+; RV32I-ILP32E-NEXT:    sw a0, 16(sp)
+; RV32I-ILP32E-NEXT:    lui a0, 262236
+; RV32I-ILP32E-NEXT:    addi a0, a0, 655
+; RV32I-ILP32E-NEXT:    sw a0, 12(sp)
+; RV32I-ILP32E-NEXT:    lui a0, 377487
+; RV32I-ILP32E-NEXT:    addi a0, a0, 1475
+; RV32I-ILP32E-NEXT:    sw a0, 8(sp)
+; RV32I-ILP32E-NEXT:    li a0, 14
+; RV32I-ILP32E-NEXT:    sw a0, 4(sp)
+; RV32I-ILP32E-NEXT:    li a0, 4
+; RV32I-ILP32E-NEXT:    sw a0, 0(sp)
+; RV32I-ILP32E-NEXT:    lui a0, 262153
+; RV32I-ILP32E-NEXT:    addi a0, a0, 491
+; RV32I-ILP32E-NEXT:    sw a0, 44(sp)
+; RV32I-ILP32E-NEXT:    lui a0, 545260
+; RV32I-ILP32E-NEXT:    addi a0, a0, -1967
+; RV32I-ILP32E-NEXT:    sw a0, 40(sp)
+; RV32I-ILP32E-NEXT:    lui a0, 964690
+; RV32I-ILP32E-NEXT:    addi a0, a0, -328
+; RV32I-ILP32E-NEXT:    sw a0, 36(sp)
+; RV32I-ILP32E-NEXT:    lui a0, 335544
+; RV32I-ILP32E-NEXT:    addi a6, a0, 1311
+; RV32I-ILP32E-NEXT:    lui a0, 688509
+; RV32I-ILP32E-NEXT:    addi a5, a0, -2048
+; RV32I-ILP32E-NEXT:    li a0, 1
+; RV32I-ILP32E-NEXT:    li a1, 11
+; RV32I-ILP32E-NEXT:    addi a2, sp, 32
+; RV32I-ILP32E-NEXT:    li a3, 12
+; RV32I-ILP32E-NEXT:    li a4, 13
+; RV32I-ILP32E-NEXT:    sw a6, 32(sp)
+; RV32I-ILP32E-NEXT:    call va5_aligned_stack_callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -64
+; RV32I-ILP32E-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 64
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va5_aligned_stack_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -64
+; ILP32E-WITHFP-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 64
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    li a0, 17
+; ILP32E-WITHFP-NEXT:    sw a0, 24(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 16
+; ILP32E-WITHFP-NEXT:    sw a0, 20(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 15
+; ILP32E-WITHFP-NEXT:    sw a0, 16(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262236
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 655
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 377487
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 1475
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 14
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 4
+; ILP32E-WITHFP-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262153
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 491
+; ILP32E-WITHFP-NEXT:    sw a0, 44(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 545260
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -1967
+; ILP32E-WITHFP-NEXT:    sw a0, 40(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 964690
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -328
+; ILP32E-WITHFP-NEXT:    sw a0, 36(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 335544
+; ILP32E-WITHFP-NEXT:    addi a6, a0, 1311
+; ILP32E-WITHFP-NEXT:    lui a0, 688509
+; ILP32E-WITHFP-NEXT:    addi a5, a0, -2048
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 11
+; ILP32E-WITHFP-NEXT:    addi a2, sp, 32
+; ILP32E-WITHFP-NEXT:    li a3, 12
+; ILP32E-WITHFP-NEXT:    li a4, 13
+; ILP32E-WITHFP-NEXT:    sw a6, 32(sp)
+; ILP32E-WITHFP-NEXT:    call va5_aligned_stack_callee@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -64
+; ILP32E-WITHFP-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 64
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va5_aligned_stack_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -48
@@ -1652,6 +2221,39 @@ define i32 @va6_no_fixed_args(...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va6_no_fixed_args:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -28
+; RV32I-ILP32E-NEXT:    sw a5, 24(sp)
+; RV32I-ILP32E-NEXT:    sw a4, 20(sp)
+; RV32I-ILP32E-NEXT:    sw a3, 16(sp)
+; RV32I-ILP32E-NEXT:    sw a2, 12(sp)
+; RV32I-ILP32E-NEXT:    sw a1, 8(sp)
+; RV32I-ILP32E-NEXT:    sw a0, 4(sp)
+; RV32I-ILP32E-NEXT:    addi a1, sp, 8
+; RV32I-ILP32E-NEXT:    sw a1, 0(sp)
+; RV32I-ILP32E-NEXT:    addi sp, sp, 28
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va6_no_fixed_args:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -36
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    sw a0, 0(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 4
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 36
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va6_no_fixed_args:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -1821,6 +2423,74 @@ define i32 @va_large_stack(i8* %fmt, ...) {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    add sp, sp, a1
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: va_large_stack:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    lui a0, 24414
+; RV32I-ILP32E-NEXT:    addi a0, a0, 288
+; RV32I-ILP32E-NEXT:    sub sp, sp, a0
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 100000032
+; RV32I-ILP32E-NEXT:    mv a0, a1
+; RV32I-ILP32E-NEXT:    lui a6, 24414
+; RV32I-ILP32E-NEXT:    addi a6, a6, 284
+; RV32I-ILP32E-NEXT:    add a6, sp, a6
+; RV32I-ILP32E-NEXT:    sw a5, 0(a6)
+; RV32I-ILP32E-NEXT:    lui a5, 24414
+; RV32I-ILP32E-NEXT:    addi a5, a5, 280
+; RV32I-ILP32E-NEXT:    add a5, sp, a5
+; RV32I-ILP32E-NEXT:    sw a4, 0(a5)
+; RV32I-ILP32E-NEXT:    lui a4, 24414
+; RV32I-ILP32E-NEXT:    addi a4, a4, 276
+; RV32I-ILP32E-NEXT:    add a4, sp, a4
+; RV32I-ILP32E-NEXT:    sw a3, 0(a4)
+; RV32I-ILP32E-NEXT:    lui a3, 24414
+; RV32I-ILP32E-NEXT:    addi a3, a3, 272
+; RV32I-ILP32E-NEXT:    add a3, sp, a3
+; RV32I-ILP32E-NEXT:    sw a2, 0(a3)
+; RV32I-ILP32E-NEXT:    lui a2, 24414
+; RV32I-ILP32E-NEXT:    addi a2, a2, 268
+; RV32I-ILP32E-NEXT:    add a2, sp, a2
+; RV32I-ILP32E-NEXT:    sw a1, 0(a2)
+; RV32I-ILP32E-NEXT:    lui a1, 24414
+; RV32I-ILP32E-NEXT:    addi a1, a1, 272
+; RV32I-ILP32E-NEXT:    add a1, sp, a1
+; RV32I-ILP32E-NEXT:    sw a1, 4(sp)
+; RV32I-ILP32E-NEXT:    lui a1, 24414
+; RV32I-ILP32E-NEXT:    addi a1, a1, 288
+; RV32I-ILP32E-NEXT:    add sp, sp, a1
+; RV32I-ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va_large_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -2044
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 2044
+; ILP32E-WITHFP-NEXT:    sw ra, 2016(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 2012(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -28
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -32
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 2020
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 24
+; ILP32E-WITHFP-NEXT:    lui a0, 24414
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -1748
+; ILP32E-WITHFP-NEXT:    sub sp, sp, a0
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 8
+; ILP32E-WITHFP-NEXT:    lui a2, 1024162
+; ILP32E-WITHFP-NEXT:    addi a2, a2, -272
+; ILP32E-WITHFP-NEXT:    add a2, s0, a2
+; ILP32E-WITHFP-NEXT:    sw a1, 0(a2)
+; ILP32E-WITHFP-NEXT:    lui a1, 24414
+; ILP32E-WITHFP-NEXT:    addi a1, a1, -1748
+; ILP32E-WITHFP-NEXT:    add sp, sp, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 2016(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 2012(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 2044
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va_large_stack:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    lui a0, 24414
diff --git a/llvm/test/MC/RISCV/target-abi-invalid.s b/llvm/test/MC/RISCV/target-abi-invalid.s
index 20e9f89153e0..906c40805866 100644
--- a/llvm/test/MC/RISCV/target-abi-invalid.s
+++ b/llvm/test/MC/RISCV/target-abi-invalid.s
@@ -30,7 +30,7 @@
 # RUN:   | FileCheck -check-prefix=RV32E-LP64 %s
 # RUN: llvm-mc -triple=riscv32 -mattr=+e,+f -target-abi lp64f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EF-LP64F %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi lp64f < %s 2>&1 \
+# RUN: not --crash llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi lp64f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EFD-LP64D %s
 
 # RV32I-LP64: 64-bit ABIs are not supported for 32-bit targets (ignoring target-abi)
@@ -39,6 +39,7 @@
 # RV32E-LP64: 64-bit ABIs are not supported for 32-bit targets (ignoring target-abi)
 # RV32EF-LP64F: 64-bit ABIs are not supported for 32-bit targets (ignoring target-abi)
 # RV32EFD-LP64D: 64-bit ABIs are not supported for 32-bit targets (ignoring target-abi)
+# RV32EFD-LP64D: LLVM ERROR: ILP32E must not be used with the D ISA extension
 
 # RUN: llvm-mc -triple=riscv32 -target-abi ilp32f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32I-ILP32F %s
@@ -66,14 +67,16 @@
 # RUN:   | FileCheck -check-prefix=RV32EF-ILP32F %s
 # RUN: llvm-mc -triple=riscv32 -mattr=+e,+f -target-abi ilp32f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EF-ILP32F %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32f < %s 2>&1 \
+# RUN: not --crash llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EFD-ILP32F %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32d < %s 2>&1 \
+# RUN: not --crash llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32d < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EFD-ILP32D %s
 
 # RV32E-ILP32: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
 # RV32EF-ILP32F: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
 # RV32EFD-ILP32F: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
+# RV32EFD-ILP32F: LLVM ERROR: ILP32E must not be used with the D ISA extension
 # RV32EFD-ILP32D: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
+# RV32EFD-ILP32D: LLVM ERROR: ILP32E must not be used with the D ISA extension
 
 nop
